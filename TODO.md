True final ToDo list:


## Documentation updates

0. Go through "What's left" post and create issues for everything. (Eventually,
rewrite "what's left" post to just link to issues, and eventually rewrite to be
autogenerated from github issues api)
1. (DONE) Fix Experiments
2. (DONE) Finish "what's left" / alpha targets blog post
3. (DONE) Fix all CDN links to point toward unpkg or jsdelivr or something
equivalent
4. (DONE-ish) Fix Demo.js to be better on mobile
5. Add Custom CPart + API example


## Bug fixes

1. Clean up
  - (DONE) nupatches  / nufactories etc
  - Possibly refactor into create/engine system (next, so we can better
    finalize config?)
        - Possibly could refactor the hashing / engine system into
          Preprocessors, shared by Template (Templater), Component
          (Reconciler), and maybe even Script (something that wraps and
          exposes, e.g.  ScriptContainer) and StaticData (DataProcessor)
  - Refactor: HTMLElement, Component CPart, lifecycle, etc
  - Fix directives with finalized config concept (and reintroduce
    directiveShortcuts to docs)
  - Refactor legacyCPartSetup
2. Do script / cpart substitution on Modulo and/or Component
3. Finish Library CPart and sort around terminology around "namespace"
"definition" "name" "TagName" etc, make it very simple and predictable. Also
possibly implement "Config" concept
4. Shadow dom?
5. Fix some TODO/XXXs
6. Get remaining ~100 extra tests running

## New features
- Finish "register=" Script syntax
- Redo build system to "record" invocations
- modulo-create
    - Finish this as the NPM quick start example
- index.html
    - Quick start info on front page? Maybe 5-line starter (sM/C/T/C/sm) on the
      left, and npm modulo on the other?
- Standard starter template for Modulo SSG based site
- Bootstrap5 starter file
- StaticData
    - Basic CSV support
    - Have it actually compile into the conf
- Script
    - Possible: If it's easy, some switch that makes the script tag the
      initialized callback, and thus isolated per-component.
    - This might be the more intuitive behavior for some, and will prevent any
      need for weird variable prep stuff
    - If it seems fast on large numbers of elements, then maybe make default,
      and possibly even make current script behavior StaticScript, or something
    - Downsides: Might be too tempting to then put state in Script
- Template
    - Possible: If it's easy, add in {% include state.templateinfo %}
      (replacing renderas), which includes given text verbatim into template.
      Somewhat more dangerous, but could finally be used for the following:
        - {% include component.innerHTML %}
        - This would allow <x-Page ....>{% if blahblah %} .... {% endif %} stuff
    - Better yet: Compile includes as separate Templaters, so that they
      generate different hashed functions

----


# (OLD) Final steps for alpha documentation launch:

- Fix tutorial part 1:
    - (DONE) Replace Library documentation with an introduction to the -src
    - MAYBE, show how different slots can be used?
- Demos page
    - (DONE) Fix all starter files
    - (DONE) Fix all MDU demo starter files, finally use absolute https


----




New new next steps:
- Maybe finally clean up Name and Namespace nonsense? General CPart hack
  refactor so we can approach this final conf issue cleanly

----



- Known bug: Built JS has "use strict"; over and over

----


- New factoryCallback flow is mostly done!
- Now getting to work on m.build()




----


New lifecycle structure:
                       (build starts here)
                          |
- conf                    |
preprocessors -> prebuild -> define

- renderObj
factory -> initialized -> prepare -> render -> reconcile -> update




----


# Inp-Mod3 notes

- Goal: Refactor current chaotic, confusing configure/define/factory steps

Steps:


1. Load a string (e.g. script[Modulo])
2. Loop through DOM nodes
3. Build ROUND1 config
4. Then, run config preprocessors
5. Did any preprocessor trigger? If so, repeat from
Step 3 for ROUND2 config
6. ROUNDX: Okay, finally no preprocessors
triggered, so we can now stop the phase


----

Rules:
1. Every CPart has a Name and Namespace
2. Both default to "x"
3. If a child CPart specifies a Namespace, it's an error
4. The Namespace of a child CPart is set by the parent when it's reading it,
and by default is the  Name and Namespace of it's parent CPart, e.g.
`"x_HelloWorld"`
4. Config looks like:


    modulo.namespaces['x'] = [
        {
            Type: 'Component',
            Name: 'HelloWorld',
            Namespace: 'x',
            mode: 'vanish-into-document',
        },
        {
            Type: 'Component',
            Name: 'Button',
            Namespace: 'x',
        },
    ];

    modulo.namespaces['x_HelloWorld'] = [
        {
            Type: 'Template',
            Content: '\n{% for i in ... ',
        },
    ];

    // not sure if useful -v
    // Config will directly mirror namespaces, except be squashed by type?
    modulo.config['x_HelloWorld'] = {
        Template: { ... }
        Script: { ... }
    }


-----------------------------

Build:

    modulo.config['x-y'] = [
    ]; // Etc


    modulo.assets.runInline(`
        customElements.define('x-y', class x_y extends HTMLElement {
            connectedCallback() {
                if (!this.isMounted) {
                    setTimeout(() => this.parsedCallback(), 0);
                }
            }
            parsedCallback() {
                modulo.registry.cparts.Component.setupElement(this, 'x-y');
                this.isMounted = true;
            }
        });
    `);


----


1. (DONE-ish) Next step: Work on necessitating LIVE version of site (not
built), using new boilerplate (it's okay to use hacks to get through)
* (INP) Work on refactoring configure / define steps
2. (INP) Work on static build of site / etc (**)
3. One by one incorporate Libraries of the old unit tests.  Will need to
punt + totally rewrite some parts (e.g. things that read in their own
fetchQ, maybe..?)
5. Finish updating documentation, polish docs, finish misc articles, then
release alpha!
* (DONE-ish) Fix Library -- current CPart code doesn't work at all

Bug note:
- Still have not restored the <Template> -> <script Template> rewriter
Bug note:
- Due to "current bug" where partialConfs get shared, with 
  tests break unless you do <template name="before"> etc

Current bug:
http://localhost:3334/
- The 'Src' doesn't work for factory-stage Template
- Queues up and only rerenders too late
- Should hardcode or fix somehow
- Note that the line here that dupes is part of what breaks it:
      - partialConfs.push(Object.assign({}, partialConf));

Misc lifecycle refactor idea:
Modulo lifecycles:
- configure - outputs data structure
- asset - sets up asset manager
      - component - definition functions['..'] & script tag in head
      - script, staticdata - factory functions['..'] & script tag in head
      - style - styles['..'] & stylesheet tag in head
      - props, state - none
- define
  - invokes component definition function
Component lifecycles:
- factory
  - invokes script definition function
- (render etc)

----

# Misc cool ideas:

- For a Python port, port to https://micropython.org/ (and/or C++, and/or C99)
- Then, there can be MicroModulo - run it on Arduino, Pi Pico, etc
- Could have CParts for turning on LEDs, e.g. setting pins etc
- Eventually, with a display, could literally
  create a "Template" like thing for building nice
  Arduino UIs
- Could use VirtualDOM with a subset of CSS implemented?
- Given how simple the code is, a port shouldn't be
  too hard, could even use same test cases















-----------------------------

# Pre-Mod3 notes

- Loading relative component libraries is broken, e.g. ./scratchlib4.html

- Decide on Loader / Module simplification
    - Possibly: Rename + condense Loader / Module to only be "Library"
    - Rationale: Less visually similar to Modulo, more descriptive, less
      confusing since "module" is a vanilla JS feature (import)
- Decide on Modulo / Config simplification
    - Remove ALL global "Modulo" object references, instead allow instantiating
      entire framework / lib as encapsulated config instance
    - Think about 'Modulo.register('cpart', 'Template', class Template extends
      CPart { });'
    - See directive idea below

- Template variable syntax change:
    - Allow '-' in identifier names, and then just do "camelcase" be default
      identifier filter

- Simple API for component rerender: mark isDirty on any lifecycle, and will
  always rerender
- Fix Reconciler1 tests so they run on other Node versions (they rely on an
  older "[object Object]" style toString that is inconsistent)
- Module syntax transformation
    - import { stuff } from "thing/whatever.js"
    - const { stuff } = Modulo.assets.functions["..hashOfScript"](Modulo);
    - export default ... or export ...
    - return ... or return ...
    - Simple transformation:
    - If elegant solution found, make part of core Script CPart / AssetManager
    - Otherwise, have an extension to AssetManager
- Aim for the simplest one-liner boilerplate entrypoint:
    - < script type="modulo/Modulo"
          src="https://unpkg.com/modulo@0.1.1/src/Modulo.js"
          -src="/static/libraries/all.html"
       >< /script >
    - OR:
    - < script Modulo (?) or... < script -Modulo> ?

- Allow '-' in identifier names, and then just do "camelcase" be default

- ModRec & DOMCursor refactor
    - Finish detangling repetitive directives and dead code
    - Finish modulo-ignore and modulo-key
    - Fix nested subrender directives
    - Possibly: Implement new patch-set data structure




-----------------------------



## Misc editor ideas

- ".modulo-container" format (just like .scrollid format)
- Just a tar of a bare git repo, with the tar file ordering so that it can have
  magic bytes / be sniffed
- Maybe contains 1) UUID and 2) commit log in .modulo-container?

## Modulo Config simplification / ordering idea (22-05)

- Maybe a "config" lifecycle, that comes after load, when all CParts have done
  initial registration?
- Could be for CParts that depend on seeing other CParts, e.g. that way Script
  can include all CParts regardless of order
- This could then DISCARD, by default, the loadObject, or something, meaning
  the loadObject IS the config? So something like loadObj.template.filters...
    - And then, the config
- Modulo.register could do this as well? E.g.
    - `Modulo.register(loadObj, 'template.filters', {...)`


-----------------------------

## MDU Components & CParts library thoughts


- Have src= be MTL templated with a obj in config
- That way, we can have Library src="{{ mdu }}/components/Button.html"
- And "mdu" can be the root to the MDU release tracked with this Modulo
  version, but can be updated easily with config
- IDEA: Config.template(...) -- apply as context to given template string



-----------------------------

## TestSuite improvements

1. Rewrite to use new Modulo / registry system
2. New RegexpTemplate logic: Instead of outputing an HTML-escaped string, it
will output regexp that can be compared to innerHTML (and thus use {% 
        // Allowing templating: (currently deactivated)
        // TODO: Rewrite templating language to make the generated function
        // return a regular expression, thus allowing stuff like
        // {% ignore TEXT %} or {% regexp "A-Za-z+" %} for more complicated matches
        //const { MTL } = modulo.templating;
        //const instance = new MTL(stepConf.Content, stepConf);
        //const text1 = _process(instance.render(stepConf));



-----------------------------

## requirejs

- A way to do silo'd JS file loading and requirements

- Likely, a highly useful core feature:

// Creates a dummy js.TagLex class, and Queues up a requirement
Modulo.assets.requirejs('https://cdn.com/mdu/taglex.js', 'TagLex');
// Does a simple wrapFunction type thing where it auto-exports. Maybe even
// Modulo.utils.TagLex?

// Extension - possibly extending real class, possibly dummy
Modulo.utils.SuperTagLex = class SuperTagLex extends Modulo.assets.js.TagLex {
}

// Finally, when real class gets loaded, set "prototype" of dummy TagLex to the
// new class, so SuperTagLex extends DummyTagLex which extends the real TagLex

// Eventually: Recommended ways of interop with JS Modules

--------


Possible repo setup:

- modulo/modulo -- src/Modulo.js, www-src, tests & docs for core
- modulo/mdu -- modulocli/, mdu/cparts, mdu/html, tests & docs for mdu
- modulo/website-common -- The component libraries for x-Page, etc, so both mdu
  and modulo can share the same look! Then, mdu.modulojs.org could be the docs
  for the "MDU" Tab.

The docs for the MDU tab could even just be literally a self-generated
storybook, inside an x-Page component


## MDU FE Ideas

- UndoState CPart, as a drop-in replacement for state
    - Could use the "time travelling" Map implementations
    - Expose "undo" state.undo and state.redo
    - Could have a super simple implementation example that's like:
        - < input @change=state.save [state.bind] > (x 10 for a form)
        - < button @click=state.undo >Undo</button> (+ redo etc)
    - No custom JavaScript code! Super impressive!



## MDU FE FreezeCPart

- Generate the code for any arbitrary CPart config:

```
Modulo.cparts.mycpart = class MyCPart extends Modulo.cparts.FetchState {
    static getAttrPreset() {
        return {
            githuburl: '//', // etc
        }
    }

    static factoryCallback(partOptions, factory, renderObj) {
        // Override the factory callback to inject attrs and content
        const { factoryCallback } = Modulo.cparts.FetchState;
        const { getAttrPreset, getContentPreset } = Modulo.cparts.mycpart;
        const { attrs, content } = partOptions;
        partOptions.attrs = getAttrPreset(attrs);
        partOptions.content = getContentPreset(content);
        return factoryCallback(partOptions, factory, renderObj);
    }
}
```

- Could be a management command!
    - Could even use saveFileAs, so it could be run from the CLI conceivably
- This would allow for quickly "spinning off" FetchState, for example, into a
  re-usable "API" Component Part that is centrally maintained.
- Could have custom configs for other MDU ones, that maybe even intelligently
  auto-generate stuff. For example, Script would come out like an actual CPart,
  and in general it could attempt to produce an idomatically correct pattern
  that could be comfortably maintained going forward.


## MDU FE StaticData

- StaticData 2 - Should add a little more code to prefix, e.g. default filter
  could be:
        const key = Modulo.statics[attrs.name || attrs.src];
        if (key in Modulo.statics) {
            return Modulo.statics[key];
        }
        Modulo.statics[key] = {{ filter }};
        return Modulo.statics[key];

- State $sync:=Modulo.statics.user - Auto-refresh

## Config Directives + Modulo config

### 2022-05-ideas

- Current idea:
    - UNIVERSAL CONFIG system
    - class Modulo is core CPart type
    - Attrs and config are the same
    - 1:1 translation from static HTML to JSON format (good for later new
      build types)
    - Maybe Config builds into factory function, with hardcoded config JSON
      (Modulo.assets['xfrea'] in place of built stuff)?
- Every sub template deep-forks

ModuloConfig = {
    "component": {
        // dataProps get set at this tier, but resolve at config tier
        "name": "XyZ",
        "mode": "shadow"
    },
    // But on the Modulo / Config tier, they start (& resolve) at Config-tier
    // e.g. <Config template.engine:=MyTemplateEngine></Config>
    // e.g. <Config template.filter.push:=MyTemplateEngine></Config>
    // Config could auto-export functions and scripts
    "script": {
        "Content": "function getclick() ...", // "Content" is the .textContent
        "Src": "" // "Src" loads Content
    },
    "state": {
        "Src": "", // "Src" loads Content? OR it's for ANY libray, e.g. -content?
        "mode": "rerender"
        "Spares": [ { } ]
    },
}

- Maybe over-thought idea, but:
    - All of Modulo is a single Config (accessible with Modulo obj)
    - When instancing:
    - dataPropMount patches happen before each factory (loadCallback)
        - cpartMount patches happen before each factory (factoryCallback)
            - Modulo config is used synchronously to instantiate object (constructor)
            - Possibly, Modulo is forked at this point into "this.modulo"
        - cpartUnmount patches happen after each factory call
    - dataPropUnmount patches happen after each factory call

- Might need to support whatever.src="" alt dataProp syntax (e.g. no ":",
  meaning, so plain string, but still reflected in dataProps for
  consistency)

- e.g. <!-- <State info={} info.stuff="Hi" info.other="Okay"></State> -->


### 2022-04-ideas

- Another idea: have "dash" prefix be for modifying config, e.g.
  '-name="Component"' or something. Maybe only for State/Props/etc, things
  that need it?
- Create a directive like "%" used at load, that sets silo'ed config based
  on path:
    - Top level: `{ "component": { "mode": "regular" } }`
    - `<Component %mode="vanish"></Component>`
    -  (turns into component.mode = "vanish" in silo'ed modulo)



## MDU CLI

- For now, focus on Puppeteer implementation, since it's most browser-similar

- Commands:
    - help
    - ssg
    - watch
    - build
    - bundle
    - postprocess
    - pregenerate
    - test
    - serve
    - servesrc

### Misc bundle improvements (MOSTLY DONE)

- Possibly: Move the innerHTML file generation to be in Modulo.js, so that
  m.build() or m.bundle() will generate a file as well
- Then, in SSG mode, it just attempts to rewrite anything with a hash in the
  filename into an absolute location, while the rest it keeps as relative
- This allows for easily hooked file generations (e.g. for
    {% thumbnail 200x200 "image.png" %} type stuff, could make
    image-x7aree.png)

- Another thing: Simpler total build structure? Have a better way to know if
  included in build, e.g. an attribute like "modulo-asset" Then, Modulo.js
  simply just collects all with the given attribute, removing it as it does so
  (everything removed gets put into an array, so it can be reapplied)
- So, build vs bundle does the same thing, the only difference is which it
  selects (e.g. "modulo-asset" marked things only, or everything)
- At the end, it generates an HTML file, possibly
- Once done with either, it also generates an HTML file

### Improvements for CLI rewrite:

- Generalize / improve global lock to prevent simultaneous SSG builds
- Generalize a "dependency" backwards to allow generate and delete to do
  partial builds


## MDU Interop tools

### Django-Modulo

- Does pregens on pages served
- Could serve squashed templates as static files so that {% include %} and {%
  extends %} works client-side
- Exposes JSON routes that can be loaded for things like urls
- Modes:
    - Component-only:
        - Dev gen only, stored in JSON file or SQLite or something, and
          preloaded in memory
        - Simply runs "npx mdu-cli interactivessr" which accepts files into
          STDIN and outputs tarballs of results
        - JSON format should just be the same as a fixture format
        - Prod gen, stored in DB (index by hash, unindexed, nullable textblob
          for both input and output)
    - Full-page:
        - Same as above, but hashing and checking every HTML response

- End goal: Modulo.py and mdu.py (transpiled implementation of Modulo + MDU in
  Python)



## MDU Server features

### Backend pre-rendered data

- "PREGEN Hook"
    - Allow arbitrary JS code to be registered as a prebuild step
    - Then CParts can load it
    - Should use dep system for this too, e.g.

- Auto-genned source files:
    - The only time it will be updating srcwww
- Allow for hooking into build-process for things like directory listings
    - e.g. .modulo-data.dirlisting.json
    - Have a CPart that makes this easy to access:
        - <StaticData source="dirlisting"></StaticData>
        - {% for filename, title of data.files %}<a href="{{ filename }}">Hi</a>{% endfor %}
- The goal is JS / build parity:
    - During dev, it will be a fetch
    - During build, it will be built like an asset, like anything else
- Later uses involve any BE <-> FE communication that can be prebaked
    - E.g. urls.py could be dumped into a JSON conf file, to allow named params


### Autogen notes

- AutoGenProvider is a type of middleware that has a strict ordering, and is
  set when configuring modulocli
- devserver has autogen providers available by default, but production server
  WILL NOT run them (thus, only run during development / build, to remain
  "static")
- During SSG, it will ONLY generate autogen files to --output if they are in a
  dependency somewhere else (e.g., when an autogen gets used during the build
  process will it be built by SSG)
- At their core, autogens are path matchers that only kick in if there is a 404
- Unlike Express routes / controller functions that get request info, autogen
  functions if matched are given config, along with one thing: path, relative
  to --input, and only return 1 thing: a result to be stored in the path

- There should be a globally set whitelisting regexp for them, e.g. if you have
  no need for potentially dubious ".md" -> ".html" type autogens, then you
  could whitelist /^\.autogen-/

- Uses:
    - / * * /.autogen-directory-listing.json - Directory listing of each dir root
    - /.autogen-package.json - Walking up above the input, first package.json


### Notes on embedding JS code in templates

- Could even just have:
{% block js %}

{% endblock js %}



### Simplest hot-reloading

- If a hot-reload is needed, push to FE that its the case
- Then, State CPart (only?) should save to localStorage
- Force refresh, then check from localStorage and restore & do rerender
- That way it's always a true refresh, but state gets remembered



### Misc note on a potential ordering bug with wait()

An outer-most wait caused all dependencies in modulo-embed to fail:

    Modulo.defineAll = function defineAll() { // NEEDS REFACTOR after config stack
        const query = 'template[modulo-embed],modulo';
        for (const elem of Modulo.globals.document.querySelectorAll(query)) {
            // TODO: Should be elem.content if tag===TEMPLATE
            Modulo.globalLoader.loadString(elem.innerHTML);
        }
        //Modulo.fetchQ.wait(() => { // BREAKS! for dependencies
        //});
    };


USed the following code to debug, to figure out the "stray" check wait eats up
the queue from children check-waits. This behavior is questionable, and the
logic in checkWait should be more robust, I think.

    checkWait() {
        console.log('--------CHECKING WAIT', Object.keys(this.queue).length);
        if (Object.keys(this.queue).length === 0) {
            const { waitCallbacks } = this;
            while (waitCallbacks.length > 0) {
                waitCallbacks.shift()(); // clear while invoking
            }
            //this.waitCallbacks = [];
            //waitCallbacks.forEach(callback => callback());
            /*
            while (this.waitCallbacks.length > 0) {
                this.waitCallbacks.shift()(); // clear while invoking
            }
            */
        }
        console.log('--------DONE CHECKING WAIT', Object.keys(this.queue).length);
    }
}


        <!-- ######################################################################### -->
        <!-- # BOILERPLATE FOR MODULO DEMOS    ####################################### -->
        <div style="position: fixed; top: 100px; right: 0; font-size: 20px; background: #ddd; z-index: 100">
            <a href="https://modulojs.org/docs/">&#x300A; BACK</a> | <a href="#" onclick="
            modulo.fetchQueue.enqueue(String(location.href), text => {
                this.nextSibling.textContent = text;
                this.parentNode.style.position = 'absolute';
                window.navigator.clipboard.writeText(text); 
                this.textContent += '  [☑ Copied to clipboard!]';
            })">COPY PAGE</a><pre></pre>
        </div>
        <!-- ######################################################################### -->

        // TODO: Remove dupes
        const cpartNameString = Children.map(({ Type }) => Type).join(', ');
        let unrolledFactoryMethods = 'const initRenderObj = {};';
        let unrolledCPartSetup = 'this.cparts = {};';
        let i = 0;
        while (i < Children.length) {
            const conf = Children[i];
            const { Type } = conf;
            unrolledCPartSetup += `\nthis.cparts.${ conf.RenderObj } = new ${ conf.Type }();`
            if (!('factoryCallback' in modulo.registry.cparts[conf.Type])) {
                i++;
                continue;
            }
            const fn = `initRenderObj.${ conf.RenderObj } = ${ conf.Type }.factoryCallback`;
            const expr = `${ fn }(initRenderObj, confArray[${ i }], modulo)`;
            unrolledFactoryMethods += '\n    ' + expr + ';';
            i++;
        }
        // TODO: When refactoring, reincoroprate the new unrolled style,
        // probably into constructor() instead of parsedCallback
        /*
                new__parsedCallback() {
                    ${ unrolledCPartSetup }
                    modulo.setupCParts(this, confArray);
                }
        */
            /*${ unrolledFactoryMethods }*/



modulo.register('util', function unrollLifecycles(modulo, lcObj, lifecycleNames) {
    let result = '';
    for (const lifecycleName of lifeCyleNames) {
        const methodName = lifecycleName + 'Callback';
        for (const [ type, obj ] of Object.entries(lcObj)) {
            if (!(methodName in obj)) {
                continue; // Skip if obj has not registered callback
            }
            const { RenderObj } = this.config[type.toLowerCase()];
            result += `renderObj.${ RenderObj } = ${ type }.${ methodName }`
            result += `(renderObj) || renderObj.${ RenderObj };`;
        }
    }
    return result;
});

