<h1>Lifecycle & Directives</h1>


<mdu-Section name="lifecycle">Lifecycle</mdu-Section>

<p>Every Modulo Component goes through a certain "lifecycle". Here's an
analogy: If CParts are the stage-hands and actors who put on a play, then the
"lifecycle" is the pre-described arrangement of each "act", intermission, and
so on, such that every CPart stage-hand "jumps in" at the right moment to do
it's job and set up for the next act.</p>

<h3>Modulo lifecycle phases</h3>

<p>Modulo lifecycle phases can be categorized into a few groups. One way to
think these phases is that typically, the "output" of a previous lifecycle
phase in a group is the "input" of the next phase. As an example,
<code>load</code> generates a flat, serializable structure that
<code>factory</code> "hydrates" into more complicated JavaScript instances.
Similarly, <code>prepare</code> figures out the template variables,
<code>render</code> causes the template to actually perform the render based on
the variables in the previous phase, and <code>update</code> updates the HTML
of the element based on the rendered output of the previous phase.</p>


<h4>Group 1: Component Definition</h4>
<p>These phases happen <em>once per component definition</em>. These will
happen even if the component is never used or instantiated anywhere, but only
defined and loaded. They are intended for setting up the component "Factory"
(blueprint for component instances).</p>

<ul>
    <li><code>load</code> - The stage of parsing a code file (eg static
    analysis).  Note that if Modulo components are cached, or if they are ever
    pre-compiled into a single JS file, this <code>load</code> phase happens
    BEFORE, and thus gets "baked-in". This means that the results of a
    <code>load</code> phase must be "serializable", such as in a JSON
    format.</li>

    <li><code>factory</code> - Any one-time, global set-up for a component
    (e.g. compiling the template). This happens after the <code>load</code>,
    but before the component is used.  Note that unlike <code>load</code>,
    <code>factory</code> happens AFTER when the page loads, and thus does not
    need to generate serializable results.</li>
</ul>

<h4>Group 2: Component Instantiation</h4>
<p>Currently, only one lifecycle phase is triggered when a component is mounted
on the page.</p>
<ul>
    <li><code>initialized</code> - happens once, every time a component is
    instantiated or mounted  (i.e. used) on a page</li>
</ul>

<h4>Group 3: Component Rendering</h4>

<p>All of 4 these lifecycle phases trigger in the following sequence every time
a component renders.  This including the first time, every manual rerender
(e.g. invoking <code>element.rerender()</code>), and ever automatic rerender
(e.g. after events or state manipulation). These will phases even trigger if
you don't have a <em>Template</em> CPart defined, although without a
<em>Template</em> there will be nothing to render.</p>

<ul>
    <li><code>prepare</code> - Gather data needed before rendering (e.g. gather
    variables for template)</li>
    <li><code>render</code> - Use the Template to render HTML code</li>
    <li><code>update</code> - Updates the DOM to reflect the newly generated
    HTML code, while applying directives. Each directive gets it's own set of
    lifecycle methods explained further below.</li>
    <li><code>updated</code> - Perform any clean-up tasks after DOM update</li>
</ul>


<h4>Group 4: Directives</h4>


<p>Directives can also have lifecycle phases. More information on them is <a
href="#directives">covered below</a>. For now, we'll look at 2 lifecycle phases
that are introduced whenever an event occurs. That is, these phases will be
available whenever you attach an event, e.g. <code>@click</code>.</p>


<ul>
    <li><code>event</code> - Triggers when an event is about to happen.</li>
    <li><code>eventCleanup</code> - Triggers after an event happened. A common
    pattern is to use this and the previous to figure out what has "changed"
    due to the event, and respond accordingly.</li>
</ul>



<h3>Hooking into a lifecycle phase</h3>

<p>The purpose of <em>lifecycle phases</em> is the <em>lifecycle methods</em>
or functions that "hook into" each phase and run during them.</p>

<p>You can get the name for a <em>lifecycle method</em> by simply suffixing the
name of the phase with the word <code>Callback</code>. For example,
<code>prepare</code> thus becomes <code>function prepareCallback() {...</code>.
Every CPart has the ability to hook into lifecycle methods by defining a method
with an expected name. This is useful for CPart developers to implement the
actual behavior and functionality of a CPart. In fact, most of CPart code is
just hooking into these different methods!</p>

<p>The <em>Script</em> CPart also exposes this interface to component
developers. This is so that you can write custom code in each component to
execute during any one of the phases. Note that you cannot hook into Group 1
phases this way, since those need to happen before your script tag is even
ready (in fact, it's the <code>factoryCallback</code> of <em>Script</em> that
hooks your custom methods into the component lifecycle.</p>

<p>Directives also have callback functions, <a href="#directives">covered
in a later section</a>.</p>

<p><strong>Try it out below:</strong></p>

<mdu-CodeExample
text='
<template>
Hello <strong>Modulo</strong> World!
Open your browser dev console to see messages...
<button @click:=script.gotClicked>Click me to generate an event</button>
</template>

<script>
    function initializedCallback() {
        console.log("initalizedCallback: Got mounted");
    }

    function prepareCallback() {
        console.log("prepareCallback: Starting to render");
    }

    function renderCallback() {
        console.log("renderCallback: Rendering!");
    }

    function updateCallback() {
        console.log("updateCallback: Reconciling the DOM!");
    }

    function updatedCallback() {
        console.log("updatedCallback: Done with render");
    }

    function eventCallback() {
        console.log("eventCallback: An event happened");
    }

    function eventCleanupCallback() {
        console.log("eventCleanupCallback: After the event");
    }

    function gotClicked() {
        console.log("(the button got clicked)");
    }
</script>
'></mdu-CodeExample>


</section>



<mdu-Section name="renderobj">renderObj</mdu-Section>

<blockquote>
<p><strong>renderObj is like "req" </strong> -
<code>renderObj</code> is comparable to the "request" or "response" objects
in many backend MVC frameworks, such as in Express.js or Django. In these,
middleware works behind the scenes to modify or construct the "request" object.
They prepare it for the controller functions that accept it as an argument, by
attaching data and injecting dependencies.  For a concrete example, enabling
Express's JSON parsing middleware adds the <code>req.json</code> attribute to
request objects, for parsing of JSON data.</p>
<p>This is what inspired the
<code>renderObj</code>: It's a plain object that gets passed along throughout
<em>all</em> of the lifecycle phases (including the factory callback!). All the
CParts, much like middleware, work together to construct it and make it ready
for component developers.</p>
</blockquote>

<p>So far in this document, we covered how lifecycle methods are central to
CParts, and that CParts are central to Modulo components in general.
Now, we will learn how <code>renderObj</code> is central to lifecycle methods.
It's how lifecycle methods pass data and communicate, as a component passes
through the different phases.</p>

<h3>renderObj and lifecycle</h3>

<p>The renderObj goes through 3 phases. The first is during set-up, the second
during component factory initialization, and the third happens every time a
component rerenders.</p>

<ol>
    <li><code>loadObj</code> - This is the version created during the
    <code>load</code> phase, and is typically just the text and attributes of
    the component definition with any pre-processing done.</li>

    <li><code>baseRenderObj</code> - The <code>loadObj</code> is copied to the
    <code>baseRenderObj</code>, which is the result of the <code>factory</code>
    phase. This might have more dependencies injected, e.g. the template CPart
    at this point will have compiled the template code a JS function.</li>

    <li><code>renderObj</code> - This is the one that component developers are
    more likely to encounter. During first render, and every time a
    <code>.rerender()</code> method is called, <code>renderObj</code> is
    duplicated from the <code>baseRenderObj</code>, and then gets passed around
    through the <code>prepare</code>, <code>render</code>, <code>update</code>,
    and <code>updated</code> phases.</li>
</ol>




<p>Typically, unless developing new CParts, you will have little need to
directly interact with the <code>renderObj</code>. You already implicitly use
it in several cases. For example,
whenever you access variables in the <em>Script</em> CPart, the
<code>state</code> variable is in fact shorthand for
<code>element.renderObj.state</code>, or whenever you access <a
href="http://icheb.local:8080/docs/templating.html#variables">variables in the
template</a> <em>CPart</em> (e.g., <code>props.text</code> is
shorthand for <code>element.renderObj.props.text</code>).
So, if you are a component developer and not a CPart developer, and you find
yourself thinking that it doesn't make a lot of sense why you'd need to access
or modify the <code>renderObj</code> explicitly... You probably don't!</p>

<p>Nevertheless, use the following example to examine the output of the
following example to see what information is available or modified at each
step:</p>


<mdu-CodeExample
text='
<template>
<label>
<input [state.bind] name="enabled" type="checkbox" />
Show messages in console</label>
</template>

<state
    enabled:=false
></state>

<script>
    function _logInfo(message, renderObj) {
        // Little helper function to do messages in console
        const formattedOutput = JSON.stringify(renderObj, null, 2);
        if (state.enabled) {
            console.log(message, formattedOutput);
        }
    }

    function prepareCallback(renderObj) {
        _logInfo("prepareCallback:",  renderObj);
    }

    function renderCallback(renderObj) {
        _logInfo("renderCallback:", renderObj);
    }

    function updateCallback(renderObj) {
        _logInfo("updateCallback:", renderObj);
    }

    function updatedCallback(renderObj) {
        _logInfo("updatedCallback:", renderObj);
    }
</script>
'></mdu-CodeExample>


<mdu-Section name="directives">Directives</mdu-Section>

<blockquote><p><strong>Directives are like "refs"</strong> - Directives have
the same uses as Refs in <a
href="https://reactjs.org/docs/refs-and-the-dom.html"
target="_blank">React</a>: &ldquo;Managing focus, text selection, or media
playback, triggering imperative animations, or integrating with third-party DOM
libraries.&rdquo;</p></blockquote>

<p><em>Directives</em> are one of the core features of Modulo. It allows for
callbacks to be triggered when a particular DOM element is "mounted" or first
appears in the DOM. It allows for your custom code to access references to DOM
nodes created after rendering.</p>

<p>Every directive has a name. Every directive is specified as an attribute on
the DOM element that you wish to gain access to, by enclosing the name in
square brackets. For example, the <em>State</em> CPart has the directive named
<code>bind</code>, making the full attribute be <code>[state.bind]</code>. Some
directives have shortcut names. For example, <code>[component.event]</code> can
be shortened to only a single at-sign, <code>@</code>.</p>

<p>Directives also have callback functions. Just like lifecycle callbacks, a
directive callback name is created by suffixing a string to the end of the name
of the directive. Unlike lifecycle callback functions, directive callback
functions end with <code>Mount</code> and <code>Unmount</code>.</p>

<h3>Built-in directives vs custom directives</h3>

<p>Modulo ships with a total of 4 built-in directives, defined by the built-in
<em>CParts</em> (1 from <em>State</em> and 3 from <em>Component</em>).
Typically, the built-in directives are all you need. However, just like with
lifecycle functions, the <em>Script</em> CPart also exposes the directive
interface to component developers. This is so that you can create custom
directives in a component to access the DOM after rendering.</p>

<p>A quick word of caution on custom directives: If you find yourself using
custom directives to do vanilla JS DOM manipulation often, you are probably
doing something wrong! They are meant as an "emergency escape hatch" to gain
access to the DOM underneath, and typically you only use them to integrate with
other libraries. The most common usage is mixing in older jQuery-style
libraries that require a reference to a DOM element. In general, it's when you
run into the limits of what Modulo is capable of doing.</p>

<p><strong>Example custom directives:</strong></p>

<mdu-CodeExample
text='
<template>
{# [script.myinput] is a custom directive, defined below #}
<input [script.myinput] />

{# [component.event] is a built-in directive (shortcut is @) #}
<button [component.event]click:=script.showInfo>
    Click me
</button>
</template>

<script>
    function myinputMount(mountOptions) {
        element.inputRef = mountOptions.el;
        // Try uncommenting the following to see data:
        //console.log("myinputMount:", mountOptions);
    }
    function showInfo(el) {
        alert("Focusing on:" + String(element.inputRef));
        element.inputRef.focus();
    }
</script>
'></mdu-CodeExample>

<!--<mdu-Section name="builtin">Built-in directives</mdu-Section>-->

<h3>Built-in directives</h3>

<p>Modulo ships with a total of 4 built-in directives, defined by the built-in
<em>CParts</em> (1 from <em>State</em> and 3 from <em>Component</em>).</p>

<ul>
    <li><code>[state.bind]</code> - Two-way binding with <em>State</em>
    data, with the key determined by the <code>name=</code> property of
    whatever it is attached to.</li>
    <li><code>[component.children]</code> - Reattach the original child
    elements that this component had when it was first mounted to a new DOM
    element.</li>
    <li><code>[component.event]</code> (<em>shortcut:</em> <code>@</code>) -
    Attach event listeners to DOM elements</li>
    <li><code>[component.resolve]</code> (<em>shortcut:</em> <code>:</code>) -
    Directly pass <code>renderObj</code> values as <em>Props</em> or
    events.</li>
</ul>

<h3>Directives vs templates</h3>

<p>Important directive facts: Directives are discovered during the
<code>update</code> lifecycle phase when DOM reconciliation is occurring, and
invoked during the <code>updated</code> phase. Note that they are independent
of the <em>Template</em> CPart: You can have a component that has no
<em>Template</em> but still may employ directives, e.g. if it generates HTML
contents some other way.</p>

<p>Not sure which to use? Short answer: Templates! Long answer: Directives deal
with direct DOM references, and thus are almost always messier to use. The <a
href="/docs/templating.html">design philosophy of Modulo's templating
system</a> is to generate a string of HTML code as a purposeful limitation
during the <code>render</code> phase, and thus prevents this messiness with a
stricter structure.</p>


<div class="InfoBox">
    <h2>Directives and template variables</h2>

    <p>Never attempt to mix <em>Template</em> CPart variables with directives.
    Directives cannot access template variables, since directives are only are
    applied after the template is fully rendered and all template variables are
    already forgotten.  As an example, consider the following code:</p>

<mdu-CodeSnippet
text='
<template>
    {% for athlete in state.team %}
        {# Broken, will not work: #}   <a href:=athlete.url>{{ athlete.name }}</a>
        {# Correct, will work: #}      <a href="{{ athlete.url }}">{{ athlete.name }}</a>


        {# Also broken, will not work: #}
        <button @click:=athlete.myClickCallback>{{ athlete.name }}</button>
        {# Correct, will work: #}
        <button @click:=script.selectOne click.payload="{{ athlete.id }}">{{ athlete.name }}</button>
    {% endfor %}
</template>
'></mdu-CodeSnippet>

    <p>The first attempt uses a directive (<code>[component.resolve]</code>, in
    this case using the colon <code>:</code> shortcut), in an attempt to "directly"
    attach the URL to href. The second attempt correctly uses the template variable
    with double curly braces to embed it as an actual HTML property.  The first
    attempt will fail because it fails to take into account that the directives
    will happen <em>after</em> rendering the template. That is, the resulting HTML
    will resemble something like this:
    &ldquo;<code>&lt;a href:=athlete.url&gt;Steph Curry &lt;/a&gt;
    &lt;a href:=athlete.url&gt;Megan Rapinoe&lt;/a&gt;
    &lt;a href:=athlete.url&gt;Aaron Rogers&lt;/a&gt;</code>&rdquo;.

    <p>In other words, the "athlete" variable <em>is a Template variable in the for
    loop</em> and will only be resolved at the templating step. Since directives
    happen after templating, there is no way to resolve the variable from the for
    loop.</p>

    <p>What is the proper use of the <code>[component.resolve]</code>
    directive, you might ask? The proper use is for direct assignment or attachment
    of values that are not strings or numbers <em>at the top level of the
    renderObj</em>. Basically, anything that can't be conveniently serialized
    into a string attribute. The common usage is passing down nested data types
    as <code>Props</code> (i.e. without having to waste memory with a massive
    JSON object serialized as an attribute), or for attaching callbacks from
    the renderObj.</p>

    <p>We see such correct usage in the second "correct" example: It
    references <code>script.selectAthlete</code> which is at the global level,
    and then attaches an ID to the DOM element as a "payload" so that the
    callback function knows which athlete was selected. This is the correct
    approach: It keeps the DOM clean and predictable in behavior, with no
    "hidden" values getting attached.</p>
</div>







