<script src="/m.js"></script>
<x-Page
    docbarselected="project-info.html"
    pagetitle="Modulo Project Information"
    navbar="docs">


<mws-Section>FAQ</mws-Section>

<h3><span alt="Question mark">?</span></h3>

<p>This FAQ, like every FAQ, is an imaginary conversation between the creator
(myself) of Modulo and imaginary people who apparently are invested in Modulo
enough to ask probing questions about it. That said, if you are a non-imaginary
person (I should hope so!) with questions about Modulo, they are welcome even
more: Contact via email, submit a pull request to this page, or add an issue to
the project on GitHub.</p>

<p>By reading this FAQ, you will get a better understanding of the motivation
of building Modulo and it's design philosophy.</p>

<hr />

<p><strong>Q: Why yet another JavaScript framework?</strong></p>
<p>A: To me, the very idea of writing YET ANOTHER JavaScript framework
is vomit inducing.<br />And yet here I am.</p>

<p>While working at Kickstart Coding, developing our Django-based
LMS, nothing quite fit the bill for a very simple JS framework to
sprinkle in some extra interactive features to an otherwise very
straight-forward multi-page web app. The current solution was a
mess of Vue and scattered vanilla JavaScript (okay, and a few old
jQuery plugins, that we'll totally get rid of ASAP totally), with
the build-step and mounting code for the Vue code getting almost as
complicated as the little it was even doing.</p>
<p>We didn't have the developer bandwidth needed for a SPA, and the
poor state of JS code was slowing down building features, not to
mention the brittle mounting process was hard to test.  If only I
could just <em>go in there and do some JS</em> without any more
fuss... but also develop using hot-reloading and a bundle in the
end. So, I gave up, gave in, and became the problem. I wrote yet
another JavaScript component framework.</p>

<hr />
<p><strong>Q: Any future plans?</strong></p>
<p>A: Yes, plenty! The goal of Modulo.js itself is to stabilize the API, polish
and bug-fix, and then not really change much or grow much after that (keep it
short and sweet). In addition to that, there is another project that is still
"experimental", and that is called <a href="/docs/mdu.html">MDU: Modulo
Developer Utilities</a>. This
project has two parts: <code>modulocli</code> and <code>mdulib</code>.

<br />
The modulocli tool is useful for both static-site generation (e.g. this site!),
and for "JAM stack" live sites. It's also useful as a companion tool for modulo
development, allows for the running of running test suites and testing of configurations.
<br />
However, it's still being documented, and the code quality requires
refactoring, so it still needs work before it's released externally. This modulocli
similar note, I have plans for a JAMstack-style SSG + server-side combo, with
live-refresh inspired by Phoenix LiveView. Finally, the goal of
<code>mdulib</code> will be to provide a standard library of useful reusable
Modulo components, CParts, and middleware, written in idiomatic Modulo
code.</p>

<hr />
<p><strong>Q: Why do you care so much about short source code
files? Don't you want a framework that does more?</strong></p>

<p>A: In my opinion, the most important feature about a framework
like this is documentation and structure, not functionality.
Specifically, my coding philosophy is that good frameworks should
have aim first and foremost to have a high "documentation to code"
ratio. This is because a framework is much more than simply a set
of libraries to import. Choosing a framework represents buy-in to
file and directory structures, recipes, best practices, code
patterns, and so on. I don't want to have to dig through
<em>other</em> people's code to figure out how to solve <em>my</em>
problems. Instead, a good framework should come "batteries
included" with documentation that clearly indicates how to solve
common problems.</p>

<p>Thus, to pump up our "doc/code" ratio, the easiest thing is to keep the
denominator as low as possible.  This is especially true for a new,
solo-developed framework project such as this one.  Similarly, I think that
frameworks should seek to be as simple and elegant as possible, especially in
this case, when the framework is a layer on top of existing web standards (the
web component standard). In this case, adding anything more would constitute
over-engineering.</p>

<hr />
<p><strong>Q: Can't you have both, however? Maybe not as a solo project, but
can't you have a big, extensive framework with big and extensive
documentation?</strong></p>

<p>Sure, it's possible, and for many situations a better choice, so you could
always use such a framework as well.  Modulo plays well with others! However,
Modulo takes a different approach.  See <a href="#philosophy">the design
philosophy "thought experiment"</a> below for for further and more thorough
discussion of Modulo's approach and it's motivation.</p>

<hr />
<p><strong>Q: 80 char line limit? 4 space indentation? Imperative
coding? What is this, Java code from the 90's?</strong></p>

<p>A: Another motivating factor for developing Modulo was how much I
appreciates libraries such as Django that maintain high quality docs and code,
and have an easy-to-follow codebase that you can always go to to understand
exact ordering or behavior of certain operations or steps. This is contrasted
with other libraries which seem to be designed first and foremost to go fast
and pass tests, but not for thorough documentation, or self-documenting code.
This is not a slight on any particular library, nor is it a claim that I write
better code&mdash;in fact, outside of Modulo.js itself, all the tooling code in
this repo is a mess!  However, for Modulo.js itself, I invested most of the
development time in refactoring it over and over (and over and over), until the
code and logical flow was as simple as possible. My goal is to make the code
readable and be a good example for novice coders. I want engineers of all skill
levels to be able to understand <em>why</em> the framework behaves the way it
does by simply reading the code that powers certain features.</p>

<p>That's where the coding standard comes in. Shorter line length and "more
intense" indentation requirements naturally causes simpler, less convoluted
code, causing desirable side-effects such as lower cyclomatic complexity in
functions. It might not be "pleasant" to write under these conditions, but code
is written once and read 1000 times. Modulo code was written to be easily read,
not easily written.</p>



<hr />
<p><strong>Q: Why call it Modulo?</strong></p>
<p>A: From Wikipeda: &ldquo;In mathematics, the term modulo is often used to
assert that two distinct mathematical objects can be regarded as equivalent if
their difference is accounted for by an additional factor.&rdquo; Basically,
it's math jargon to say two things are equivalent in a given condition or
context.</p>

<p>So, maybe the goal of Modulo is provide that context, making a natural way
to integrate the new and the old! Or maybe it sounded cool. Maybe that!</p>

<hr />
<p><strong>Q: Isn't <em>Modulo</em> already a thing in
JavaScript?</strong></p>
<p>A: Ironically, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder">JavaScript does not have a modulo operator</a>!
Instead, it uses the percent sign as a <em>remainder operator</em>,
which behaves similarly for some numbers, but differs for negative
numbers. So, while Modulo.js is not the first thing to be called
<abbr title="At the time of picking the name, there were a couple
similarly named projects, though none seem to be in active use or
development for years.">"Modulo" in JS</abbr> it <em>is not</em>
named after the <code>%</code> operator in JavaScript, making both the logo and
the name a bit of a pedantic and tongue-in-cheek jab at our favorite (but
sometimes deficient) computer language.</p>



<mws-Section name="workflow">Learning and workflow</mws-Section>

<p>In this section, I'll explain how Modulo was designed with learners and dev
shops in mind. Modulo was designed observing the pitfalls involved with 1)
ramping up new coders, 2) new coder learning component frameworks, and 3)
industry workflow patterns.</p>



<h3>1. Ramping up new coders</h3>

<p>The first task that Modulo was designed to tackle was the task of ramping up
novice engineers or junior hires, such as coders who only know HTML and
CSS.</p>

<p>It used to be that the cutting-edge of software development offered easy
"ramp ups" from HTML and CSS: PHP, jQuery, and even stacks like ColdFusion or
old-school ASP, all enabled HTML and CSS developers to "spice up" their static
sites with backend logic or frontend behavior, only by sprinkling in some
cut-and-paste examples or learning a few concepts at a time.  This is how I
learned coding web app coding: One tiny bit of PHP at a time. However, this is
no longer an option. Even modern PHP with an MVC framework typically resembles
other backend development more (in other words, does not provide this ramp-up),
and jQuery is largely obsoleted by built-in browser features (notably,
<code>querySelector</code>) and more sophisticated frontend frameworks such as
React. This is good, since the previous approaches were completely
unmaintainable as web-app behavior grows in complexity. Any dev shop without a
more sophisticated MVC framework either ended up developing their own informal,
chaotic MVC framework out of pure necessity, or just suffered from paralyzing
technical debt, spending time hunting down SQL statements scattered throughout
their sprawling directory tree of PHP files.</p>

<p>So, how do we provide this ramp-up today, without falling into the traps of
yesterday? Modulo provides a clear ramp-up from static HTML to JavaScript apps.
Even with the ramp-up, it still keeps components encapsulated, and permits
code-sharing via component libraries. It's basis on simple web-standards even
permits a "final ramp-up" to another JavaScript framework all together, if
Modulo's immature feature-set falls short.</p>

<p>While still in heavy development and undocumented, the
<code>modulocli</code> static-site generator used to generate this page is also
based on that ramp-up concept, with a rule of 1:1 correspondence between input
and output.  This enables people only familiar with manually built static sites
to more easily reason with and understand the purpose of static site
generation.  Furthermore, if static sites fall short, the option for a full
stack app is always available, since <code>modulocli</code> also permits
spinning up a backend server too as a convenience.</p>



<h3>2. Novices learning component frameworks</h3>

<p>At this point, I've taught <em>a lot</em> of novice engineers to code using
React JavaScript <a href="https://kickstartcoding.com/">at my coding school
Kickstart Coding</a>. I've learned that JavaScript is more difficult for
newbies than other languages such as Python, generally due to confusion around
async topics and the large number of variants, versions, and coding styles
resulting in code snippets they find online being harder to integrate.  I've
also learned that React in particular is tricky for beginners, and can even be
difficult for more intermediate programmers who are just not used to thinking
in terms of directional data-flow, state, and so on.</p>

<p>When designing Modulo, I wanted to create a framework that resembled React,
but designed from the ground-up to be easier to learn. When teaching React, I
found that learners benefit most when they see clear, explicit connections. For
example, I found it easier to explain the concept and use of state data when
there was an explicit state object (i.e. <code>this.state</code>) to point to
instead of various variables or properties (as with React Hooks, or other
frameworks like Vue.js or Svelte). Other challenges I noticed were with JSX:
The idea of mixing XML and embedded JavaScript is extremely powerful, but
perhaps too powerful for newer developers who are also learning JavaScript for
the first time. Using a Liquid-style templating language makes component HTML
development resemble templating, which is more easily understood than DOM-tree
building with a XML/JS syntax hybrid, and is more widely familiar, as some
email template software uses similar syntax.  Similarly, moving "click event"
functions to their own "zone" in the component definition (the <em>Script</em>
CPart), makes it easier for new developers to find, and distinguish what is
custom functionality from general boilerplate.</p>



<h3>3. Industry workflow patterns</h3>

<p>A common software team structure might consist of designers who produce
mockups, with specs often written in CSS units (e.g. 3px margin, color is of a
certain pallet, etc), frontend developers turn these into React JavaScript
components, and finally backend developers developing APIs to permit the
features. There exists several clear "separations" or "gaps" in skillsets in
this workflow which can result in unfortunate amounts of back-and-forth,
especially between the frontend developer and the designer. Many designers are
comfortable with the basics of CSS, but have trouble with a modern frontend
stack. This, I think, is a core problem that many "no code" solutions seek to
solve: How can we give the designers more control so there's less
back-and-forth between them and developers?</p>

<p>The goal of Modulo is to enable designers who may only have comfort with
HTML and CSS to begin developing components directly. By combining a simple
templating language with components that "ramp up" from plain HTML and CSS,
designers can give component development a "first pass" before even handing it
off to JavaScript developers for any more custom aspects. While not finished
yet, there is also plans to make sure it integrates well with <a
href="https://storybook.js.org/">Storybook</a> and similar "component library
show-cases". Modulo's declarative style of CParts is unusually well suited to
this, enabling more easily categorized behavior of components.</p>

<p>Perhaps more importantly, the "CPart" abstraction enables an entirely new
alternative structure for a frontend team: Designers, component developers, and
CPart developers. In this structure, designers focus on mockups, component
developers use HTML and CSS to bring those mockups to life, and CPart
developers do all the heavy JavaScript development, writing an internal library
of custom CParts that interface with necessary APIs or code certain behavior.
Using this model, the component developers might never use the <em>Script</em>
CPart: Instead, all custom JavaScript behavior is coded in custom CParts by the
CPart developers, and then re-used by the component developers wherever that
custom behavior is needed. This enables cleaner separation of duties: CPart
developers are the only role that requires JavaScript coding chops, developing
CParts that handle the nitty-gritty of interfacing with backend APIs, but not
needing to know anything about styling or even UX or user-facing behavior.
Similarly, Component developers can avoid needing to know much about the
backend, about API usage, or even JavaScript at all: They just need to be
comfortable "snapping together" CParts.</p>

<p>Finally, from a big picture framework design perspective, I think this sort
of "ramp up" is a sign of good framework design in general. I think writing
documentation for newbies makes it easier for pros to pick up as well, and
forces complex ideas into simpler packages.  When deadlines aren't pressing
down on us, I often view software library development, including development of
internal libraries, as sort of like creating a mini-framework (or even a sort
of domain-specific language that happens to be a subset of the original
language), that is especially suited to solving the task at hand. Eventually,
as you build upon layers of abstraction, you have created a "DSL" that enables
an expression or statement that solves the problem, expressed in a very
high-level way. Good frameworks, in my opinion, are both written with this in
mind, but also expose that to framework extenders, in the form of middleware
interfaces.  CParts are basically a form of powerful middleware.  In this case,
that's what Modulo enables you to do: You can develop a collection of CParts
that turn your configured version of Modulo into a sort of "DSL" to solve
specific issues in your specific problem domain.</p>




<hr />

<mws-Section name="philosophy">Framework design philosophy</mws-Section>

<p>In this section, I'll give some of my design philosophy and opinions on what
makes a good framework. I don't think my opinions are particularly unusual or
novel, but I thought I'd lay them out here nonetheless.</p>

<p>Let's do a thought experiment. Imagine the most minimalist JS component
framework possible. Let's call it "Fish" (probably already a thing, but bare
with me), by Tux the Penguin (because hey, why not?). Here is the complete code
for the "Fish" framework:</p>

<mws-Demo
text='
<script>
// Fish Framework - (C) 2091 - Tux the Penguin
function Fish(el, key, value) {
    el.state = el.state || JSON.parse(el.getAttribute("x-state") || "{}")
    el.state[key] = value;
    el.innerHTML = el.innerHTML.replace(/\$\{([^\)]+)?\}/g, (a, b) => el.state[b]);
}
</script>
'></mws-Demo>

<p>Now, Tux could just publish this by itself, and no one would ever want to
use it, since it it's just several lines of useless, undocumented code. People
copy &amp; paste far more code from Stack Overflow just for simple tasks!</p>

<p>However, now imagine Tux wrote documentation for it. Imagine Tux wrote a
massive recipe book of hundreds of examples, ranging from API usage to common
UI tasks.  For an example, skim (no need to actually thoroughly read) the
following "excerpt" of the imaginary "Fish" documentation:</p>

<mws-Demo
text='
<!-- Fish Framework - Documentation -->

<!-- BEGINNER EXAMPLE: BUTTON -->
<!-- Look how easy it is to make a button that counts: -->
<button
        onClick=&apos;Fish(this, "count", this.state.count++)&apos;
        x-state=&apos;{"count": 3}&apos;>
    <p>I ate {count} delicious herrings</p>
</button>

<!-- Okay, lets break it down:
        - By using the x-state directive, the core directive of Fish (see
          Chapter 2 on directives and how to create your own), we can set the
          initial state of an element.
        - What is state? An object that you can mutate to affect how your
          elements are displayed. Use it to store data from the DB, or
          elsewhere.
        - ... snip ...
-->

<!-- ADVANCED EXAMPLE: API -->
<!-- Lets see another example of state, this time with API: -->
<div x-state=&apos;{"search": ""}&apos;>
    <p>Information about account found: Their name is {name}</p>
    <input onChange=&apos;Fish(this.parentNode, "search", this.value)&apos;
        placholder="Type in a GitHub username..."
    />
    <button onClick=&apos;
        fetch(`https://api.github.com/users/${this.parentNode.state.search}`)
            .then(response => response.json())
            .then(({name}) => Fish(this.parentNode, "name", name))
        &apos;>Search GitHub</button>
</div>

<!-- Okay, lets break it down:
        - In this example, you can see how ........... (- snip -) -->



<!-- UI TOOLKIT EXAMPLE: ACCORDIAN TOGGLE -->
<!-- Or, look how you can make toggle accordians elements just by using .... -->
<nav x-state=&apos;{}&apos;>
    <li onClick=&apos;Fish(this.parentNode, "info_class", "visible")&apos;>
        Show Info
    </li>
    <li onClick=&apos;Fish(this.parentNode, "contact_class", "visible")&apos;>
        Show Contact
    </li>
    <li onClick=&apos;Fish(this.parentNode, "blog_class", "visible")&apos;>
        Show Blog
    </li>
    <div class="{info_active}">Hi, this is info about my website...</div>
    <div class="{contact_class}">I live in Antarctica and write free software...</div>
    <div class="{blog_class}">Thoughts on fish: Why fish is actually...</div>
</nav>
'></mws-Demo>

<p>Now this is looking more and more like a complete framework! The missing
ingredient was documentation and examples. In fact, that was even more
important than the original code: The original code could be anything, just
setting up a stack, checking up some attributes, whatever, but without the
patterns  of usage around the original code it is meaningless nonsense.</p>

<p>In other words, when people think of a framework, they don't think of how
it's coded, they think what they can do with it. Thus, a framework can be
better thought of as a bundle of best practices and workflow, or a recipe book.
The "code" of the framework is immaterial, as long as the documented examples
work. In this case, the code was only a few lines long, yet the examples showed
that it could be used for a myriad of tasks.  In fact, these sorts of snippets
in the documentation can be thought of as being as much part of the framework
as anything else: That is how "best practices" and "common patterns" are
established.</p>

<p>In my view, non-opinionated frameworks are incomplete to the extent they
don't have opinions. That's not to say they are bad or useless, "unopinionated"
has it's time and place, but it's just to acknowledge that they are BYO ("bring
your own") for anything that the documentation doesn't explicitly establish
patterns of usage.  Just look at the dozens of ways that Redux is implemented
in the industry, for an example. Just saying that you use "Redux" tells little
about the code structure or practices, or the myriad of middleware that is
typically incorporated to handle various common use-patterns. Redux Toolkit
(which <em>is</em> actually opinionated) can make projects look entirely
different than the "BYO" Redux projects! Once you "bring your own" patterns to
fill in these gaps, only then the framework is "truly complete", using the
nomenclature I'm using in this document, at least. One Redux setup might be so
different than another due to patterns of usage, that the lines defining them
are a bit fuzzier, in some cases to the point where it's difficult to share
code between different interpretations of the same framework, making it almost
like a different framework altogether.</p>

<p>With any project, very quickly the "userland" (e.g. developer's)
code eclipses the framework code in size and performance impact, which means
these best practices and pattern recipes can have a much bigger impact on the
resulting product than internal implementations. If the documentation shows
many slow performing examples, or if it doesn't suggest anything at all and
developers tend to go for slow implementations, I think it's perfectly fair to
say that the framework is "slow", regardless of the internal operations. (An
adjective that no doubt applies to Modulo as well, to be fair!)</p>


<p>Modulo's goal is short code and long docs. It's basically "Fish", but
multiplied times 250. It's as though Tux continued hacking away, bringing it
from 5 lines to about 1000 lines, and then kept on hacking away at docs,
examples, and use-patterns, keeping them still proportionally much longer.</p>

<p>Coincidentally, this is actually somewhat how various parts of Modulo
originally were developed.  Modulo itself had an earlier incarnation called
MoEdCo (Modular Editor Components), which was a Web Components framework in
less than 500 lines for Electron.js. That, in turn, evolved out of a demo that
I live coded for a class I was teaching on React JavaScript back in 2017. The
in-class demo was a "React-like" in just a few dozen lines of code, to explain
the core philosophy and patterns used by React without the extra baggage of the
new JSX syntax and complicated build environment (webpack, babel, etc).
Similarly, the Modulo Template Language evolved out of <a
href="https://www.npmjs.com/package/tinytiny">TinyTiny</a>, which was an
expanded version of an even shorter "codegolf" challenge that I had done for
fun (now about a decade ago).</p>

<hr />

<p>Summary: A framework isn't just code, it's an entire workflow and way of
doing things. The code is important, but less important than the other
aspects.</p>

<p>Also, for clarity's sake: The "Fish" code above is untested, incomplete, and
almost certainly has deal-breaking bugs, but could work in principle with a
tweak or two and the right context. This doesn't matter either way for our
purposes.  Also, I'm very far from the first person to approach framework
development this way &mdash; in fact, the increasingly popular Alpine.js
follows a similar principle! It also happens to resemble my silly "Fish"
example, but is actually real and truly useful, so if you want an actually
production-ready version of this, <a href="https://alpinejs.dev/">check it
out</a>. If the "component-oriented" structure of Modulo is not your cup of
tea, but you still want a tiny, modern, drop-in JS framework, Apline.js could
be a good option!</p>




</x-Page>
