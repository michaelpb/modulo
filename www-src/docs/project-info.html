<script src="/m.js"></script>
<x-Page
    docbarselected="project-info.html"
    pagetitle="Modulo Project Information"
    navbar="docs">


<mws-Section>FAQ</mws-Section>

<h3><span alt="Question mark">?</span></h3>

<p>This FAQ, like every FAQ, is an imaginary conversation between the creator
(myself) of Modulo and imaginary people who apparently are invested in Modulo
enough to ask probing questions about it. That said, if you are a non-imaginary
person (I should hope so!) with questions about Modulo, they are welcome even
more: Contact via email, submit a pull request to this page, or add an issue to
the project on GitHub.</p>

<p>By reading this FAQ, you will get a better understanding of the motivation
of building Modulo and it's design philosophy.</p>

<hr />

<p><strong>Q: Why yet another JavaScript framework?</strong></p>
<p>A: To me, the very idea of writing YET ANOTHER JavaScript framework
is vomit inducing.<br />And yet here I am.</p>

<p>While working at Kickstart Coding, developing our Django-based
LMS, nothing quite fit the bill for a very simple JS framework to
sprinkle in some extra interactive features to an otherwise very
straight-forward multi-page web app. The current solution was a
mess of Vue and scattered vanilla JavaScript (okay, and a few old
jQuery plugins, that we'll totally get rid of ASAP totally), with
the build-step and mounting code for the Vue code getting almost as
complicated as the little it was even doing.</p>
<p>We didn't have the developer bandwidth needed for a SPA, and the
poor state of JS code was slowing down building features, not to
mention the brittle mounting process was hard to test.  If only I
could just <em>go in there and do some JS</em> without any more
fuss... but also develop using hot-reloading and a bundle in the
end. So, I gave up, gave in, and became the problem. I wrote yet
another JavaScript component framework.</p>

<hr />
<p><strong>Q: Any future plans?</strong></p>
<p>A: Yes, plenty! The three main ones: SSG, server-side, and MDU.
Currently, this site is already getting generated with a
Modulo-based SSG. However, it's undocumented and messy, so it still
needs work before it's released externally. On a similar note,
there are plans for a JAMstack-style SSG + server-side combo, with
live-refresh inspired by Phoenix LiveView. Finally, developing this
site requires developing some key components, so I also hope to
have time to document and release "mdu", which will be a standard
library of Modulo components, including a Router system inspired by
React Router.</p>

<hr />
<p><strong>Q: Why do you care so much about short source code
files? Don't you want a framework that does more?</strong></p>

<p>A: In my opinion, the most important feature about a framework
like this is documentation and structure, not functionality.
Specifically, my coding philosophy is that good frameworks should
have aim first and foremost to have a high "documentation to code"
ratio. This is because a framework is much more than simply a set
of libraries to import. Choosing a framework represents buy-in to
file and directory structures, recipes, best practices, code
patterns, and so on. I don't want to have to dig through
<em>other</em> people's code to figure out how to solve <em>my</em>
problems. Instead, a good framework should come "batteries
included" with documentation that clearly indicates how to solve
common problems.</p>

<p>Thus, to pump up our "doc/code" ratio, the easiest thing is to keep the
denominator as low as possible.  This is especially true for a new,
solo-developed framework project such as this one.  Similarly, I think that
frameworks should seek to be as simple and elegant as possible, especially in
this case, when the framework is a layer on top of existing web standards (the
web component standard). In this case, adding anything more would constitute
over-engineering.</p>

<hr />
<p><strong>Q: Can't you have both, however? Maybe not as a solo project, but
can't you have a big, extensive framework with big and extensive
documentation?</strong></p>

<p>Sure, it's possible, in some cases situations better, and you can use always
that too.  Modulo plays well with others! However, Modulo takes a different approach.
See <a href="#philosophy">the design philosophy "thought experiment"</a> below for
for further and more thorough discussion of Modulo's approach and it's
motivation.</p>

<hr />
<p><strong>Q: 80 char line limit? 4 space indentation? Imperative
coding? What is this, the 90's?</strong></p>

<p>A: Another motivating factor for developing Modulo was how much I
appreciates libraries such as Django that maintain high quality docs and code,
and have an easy-to-follow codebase that you can always go to to understand
exact ordering or behavior of certain operations or steps. This is contrasted
with other libraries which seem to be designed first and foremost to go fast
and pass tests, but not for thorough documentation, or self-documenting code.
This is not a slight on any particular library, nor is it a claim that I write
better code&mdash;in fact, outside of Modulo.js itself, all the tooling code in
this repo is a mess!  However, for Modulo.js itself, I invested most of the
development time in refactoring it over and over (and over and over), until the
code and logical flow was as simple as possible. My goal is to make the code
readable and be a good example for novice coders. I want engineers of all skill
levels to be able to understand <em>why</em> the framework behaves the way it
does by simply reading the code that powers certain features.</p>

<p>That's where the coding standard comes in. Shorter line length and "more
intense" indentation requirements naturally causes simpler, less convoluted
code, causing desirable side-effects such as lower cyclomatic complexity in
functions. It might not be "pleasant" to write under these conditions, but code
is written once and read 1000 times. Modulo code was written to be easily read,
not easily written.</p>



<hr />
<p><strong>Q: Why call it Modulo?</strong></p>
<p>A: From Wikipeda: &ldquo;In mathematics, the term modulo is often used to
assert that two distinct mathematical objects can be regarded as equivalent if
their difference is accounted for by an additional factor.&rdquo; Basically,
it's math jargon to say two things are equivalent in a given condition or
context.</p>

<p>So, maybe the goal of Modulo is provide that context, making a natural way
to integrate the new and the old! Or maybe it sounded cool. Maybe that!</p>

<hr />
<p><strong>Q: Isn't <em>Modulo</em> already a thing in
JavaScript?</strong></pHere>
<p>Ironically, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder">JavaScript does not have a modulo operator</a>!
Instead, it uses the percent sign as a <em>remainder operator</em>,
which behaves similarly for some numbers, but differs for negative
numbers. So, while Modulo.js is not the first thing to be called
<abbr title="At the time of picking the name, there were a couple
similarly named projects, though none seem to be in active use or
development for years.">"Modulo" in JS</abbr> it <em>is not</em>
named after the <code>%</code> operator in JavaScript, making both
the logo and name are a bit of a tongue-in-cheek jab at our
favorite (but often deficient) computer language.</p>


<hr />

<mws-Section name="philosophy">Framework design philosophy</mws-Section>

<p>In this section, I'll give some of my design philosophy and opinions on what
makes a good framework.</p>

<p>Let's do a thought experiment. Imagine the most minimalist framework
possible. Let's call it "Zen" (probably already a thing, but bare with me), by
Tux the Penguin (because hey, why not?). Here is the complete code for the
"Zen" framework:</p>

<mws-Demo
text='
<script>
// Zen Framework - (C) 2091 - Tux the Penguin
function Zen(el, key, value) {
    el.state = el.state || JSON.parse(el.getAttribute("x-state") || "{}")
    el.state[key] = value;
    el.innerHTML = el.innerHTML.replace(/\$\{([^\)]+)?\}/g, (a, b) => el.state[b]);
}
</script>
'></mws-Demo>

<p>Now, Tux could just publish this by itself, and no one would ever want to
use it, since it it's just several lines of useless, undocumented code. People
copy &amp; paste far more code from Stack Overflow just for simple tasks!</p>

<p>However, now imagine Tux wrote documentation for it. Imagine Tux wrote a
massive recipe book of hundreds of examples, ranging from API usage to common
UI tasks.  For an example, skim this "excerpt" of the imaginary "Zen"
documentation:</p>

<mws-Demo
text='
<!-- Zen Framework - Documentation -->

<!-- BEGINNER EXAMPLE: BUTTON -->
<!-- Look how easy it is to make a button that counts: -->
<button
        onClick=&apos;Zen(this, "count", this.state.count++)&apos;
        x-state=&apos;{"count": 3}&apos;>
    <p>I ate {count} delicious herrings</p>
</button>

<!-- Okay, lets break it down:
        - By using the x-state directive, the core directive of Zen (see
          Chapter 2 on directives and how to create your own), we can set the
          initial state of an element.
        - What is state? An object that you can mutate to affect how your
          elements are displayed. Use it to store data from the DB, or
          elsewhere.
-->

<!-- ADVANCED EXAMPLE: API -->
<!-- Lets see another example of state, this time with API: -->
<div x-state=&apos;{"search": ""}&apos;>
    <p>Information about account found: Their name is {name}</p>
    <input onChange=&apos;Zen(this.parentNode, "search", this.value)&apos;
        placholder="Type in a GitHub username..."
    />
    <button onClick=&apos;
        fetch(`https://api.github.com/users/${this.parentNode.state.search}`)
            .then(response => response.json())
            .then(({name}) => Zen(this.parentNode, "name", name))
        &apos;>Search GitHub</button>
</div>

<!-- Okay, lets break it down:
        - In this example, you can see how ........... (- snip -) -->



<!-- UI TOOLKIT EXAMPLE: ACCORDIAN TOGGLE -->
<!-- Or, look how you can make toggle accordians elements just by using .... -->
<nav x-state=&apos;{}&apos;>
    <li onClick=&apos;Zen(this.parentNode, "info_class", "visible")&apos;>
        Show Info
    </li>
    <li onClick=&apos;Zen(this.parentNode, "contact_class", "visible")&apos;>
        Show Contact
    </li>
    <li onClick=&apos;Zen(this.parentNode, "blog_class", "visible")&apos;>
        Show Blog
    </li>
    <div class="{info_active}">Hi, this is info about my website...</div>
    <div class="{contact_class}">I live in Antarctica and write free software...</div>
    <div class="{blog_class}">Thoughts on fish: Why fish is actually...</div>
</nav>
'></mws-Demo>

<p>Now this is looking more and more like a complete framework! The missing
ingredient was documentation and examples. In fact, that was even more
important than the original code: The original code could be anything, just
setting up a stack, checking up some attributes, whatever, but without the
patterns  of usage around the original code it is meaningless nonsense.</p>

<p>In other words, when people think of a framework, they don't think of how
it's coded, they think what they can do with it. Thus, a framework can be
better thought of as a bundle of best practices and workflow, or a recipe book.
The "code" of the framework is immaterial, as long as the documented examples
work. In this case, the code was only a few lines long, yet the examples showed
that it could be used for a myriad of tasks.  In fact, these sorts of snippets
in the documentation can be thought of as being as much part of the framework
as anything else: That is how "best practices" and "common patterns" are
established.</p>

<p>In my view, non-opinionated frameworks are incomplete to the extent they
don't have opinions. That's not to say they are bad or useless, "unopinionated"
has it's time and place, but it's just to acknowledge that they are BYO ("bring
your own") for anything that the documentation doesn't explicitly establish
patterns of usage.  Just look at the dozens of ways that Redux is implemented
in the industry, for an example. Just saying that you use "Redux" tells little
about the code structure or practices, or the myriad of middleware that is
typically incorporated to handle various common use-patterns. Redux Toolkit
projects can look entirely different than other Redux projects! Once you "bring
your own" patterns to fill in these gaps, only then the framework is "truly
complete" (using the nomenclature I'm using in this document, at least). One
Redux setup might be so different than another due to patterns of usage, that
the lines defining them are a bit fuzzier, and they might as well be a
different framework.</p>

<p>With any project, very quickly the "userland" (e.g. developer's)
code eclipses the framework code in size and performance impact, which means
these best practices and pattern recipes can have a much bigger impact on the
resulting product than internal implementations. If the documentation shows
many slow performing examples, or if it doesn't suggest anything at all and
developers tend to go for slow implementations, I think it's perfectly fair to
say that the framework is "slow", regardless of the internal operations. (An
adjective that probably applies to Modulo as well!)</p>


<p>Modulo's goal is short code and long docs. It's basically "Zen", but
multiplied times 250. It's as though Tux continued hacking away, bringing it
from 5 lines to about 1000 lines, and then kept on hacking away at docs,
examples, and use-patterns, keeping them still proportionally much longer.</p>

<p>Coincidentally, this is actually somewhat how various parts of Modulo
originally were developed.  Modulo itself had an earlier incarnation called
MoEdCo (Modular Editor Components), which was a Web Components framework in
less than 500 lines for Electron.js. That, in turn, evolved out of a demo that
I live coded for a class I was teaching on React JavaScript back in 2017. The
in-class demo was a "React-like" in just a few dozen lines of code, to explain
the core philosophy and patterns used by React without the extra baggage of the
new syntax and complicated build environment. Similarly, the Modulo Template
Language evolved out of <a
href="https://www.npmjs.com/package/tinytiny">TinyTiny</a>, which was an
expanded version of an even shorter "codegolf" challenge that I had done for
fun (now about a decade ago).</p>

<hr />

<p>Summary: A framework isn't just code, it's an entire workflow and way of
doing things. The code is important, but less important than the other
aspects.</p>

<p>Also, for clarity's sake: The "Zen" code above is untested, incomplete, and
almost certainly has deal-breaking bugs, but possibly could work in principle
with a tweak or two and the right context. This doesn't matter either way for
our purposes.  Also, I'm very far from the first person to approach framework
development this way &mdash; in fact, the increasingly popular Alpine.js
follows a similar principle! It also happens to resemble my silly "Zen"
example, but is actually real, so if you want a neat-o real-life version of
this, <a href="https://alpinejs.dev/">check it out</a>.</p>




</x-Page>
