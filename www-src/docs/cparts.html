<script src="/m.js"></script>

<x-Page
    docbarselected="cparts.html"
    pagetitle="CParts"
    navbar="docs">

<h1>CParts</h1>


<blockquote>
<p><strong>Custom CParts?</strong> Here we describe core CParts used by
component developers, which are sufficient for most common use-cases.
However, if you are instead looking to extend this core functionality with
custom CParts written in JavaScript, refer to the <a href="/docs/api.html">API
&amp; Extension documentation</a>.</p>
</blockquote>

<p>The central concept to Modulo is that of <em>Component Parts</em>. Because
it is so central, saying <em>Component Parts</em> over and over gets tiresome,
so it's typically shortened to <em>CParts</em>. Every component definition
consists of configuring one or more CPart definitions. Modulo comes
"batteries-included" with about 8 CParts, which provide the core functionality
of building Modulo Components, and are documented here.</p>

<p>Conventionally, when defining components, CParts are listed in the following
order within a given <em>Component</em> definition:</p>

<ol>
    <li>Props</li>
    <li>Template</li>
    <li><em>(Any custom CParts)</em></li>
    <li>State <em>(and/or Store)</em></li>
    <li>Script</li>
    <li>Style</li>
</ol>

<p>The rationale for this ordering is to put Props and Template first since
they are often the first CParts that are important to read when trying to
understand or debug the behavior of a Component, while putting Style last as
it's typically the least important to read.</p>


<mws-Section name="props">Props</mws-Section>

<blockquote>
<p><strong>Read-only</strong> Props are read-only within a component, and only
be set by the parent component. If the values change, the component re-renders
with the new values. They are only supposed to be information being <em>passed
to</em> the component, which means they can't be changed internally.  For
internal, mutable data, use <a href="#state">State</a> instead.</p>
</blockquote>


<p>Props allow components to receive data. You can think of Props as being like
"function parameters": They allow you to pass down "arguments" (attributes) to
component which can then modify it's appearance, behavior, or content based on
the values of these parameters. For more discussion of Props, see
<a href="/docs/tutorial_part2.html#props">Tutorial Part 2</a>.</p>

<p>Props are set by the parent component (or HTML page).  For String values,
use plain attributes (e.g. <code>&lt;x-Btn design="round"&gt;</code>).  For any
non-String types, you can use <em>data props</em> set using a <code>:=</code>
directive syntax for (e.g.
<code>&lt;x-Chart data:='[1, 2, 3]'&gt;</code>).</p>



<h3>Definition</h3>

<p>Every "prop" within a <em>Props</em> CPart definition can be defined in one
of 4 ways:</p>

<ol>
    <li><strong>Any type, required</strong> - Specify the name of the prop in
    the CPart definition, but give it no value. This will be able to receive
    data in any type (e.g. String, and/or a JSON type or Function set with
    <code>:=</code> data prop syntax). By default, all props are required,
    meaning if this component is used without a required prop being set, it
    will throw an error and will not render.</li>

    <li><strong>Type-checked, required</strong> - Give the name of a <em>type
    validator</em> as a value when defining a Prop to enforce data of only
    certain types being accepted by a Component. There are a number of built-in
    <em>type validators</em> that you can use for common types:
    <code>String</code>, <code>Number</code>, <code>Boolean</code>,
    <code>Array</code>, <code>Object</code>, <code>Date</code>, and
    <code>Function</code>. You can also create your own validators: The
    <em>type validator</em> can be the name of any function that will return
    <code>undefined</code> if the given prop is of an incorrect type, or
    the value of the prop (with any necessary "casting" or conversion applied)
    if it's a valid Prop.  The Props CPart will then use these validators to
    provide more helpful error messages. If you want to support more than one
    type, allowing <em>any</em> of them, use comma separation (without
    spaces).</li>

    <li><strong>Any type, optional with default</strong> - To make an optional Prop, you
    must specify it's default value.  To specify a default value, repeat
    attribute with a <code>.default</code> suffix. If a default is specified,
    the component will no longer cause an error when it does not encounter a
    value, but instead use the default value.   If you don't expect to use the
    default value, but still want to make a prop optional nonetheless (e.g.
    perhaps  its usage is dependent on the value of another prop), consider
    setting the default value with <code>:=null</code>.</li>


    <li><strong>Type-checked, optional with default</strong> - Finally, by
    combining both type-checking with specifying default values, we can make
    Props that are both type-checked and optional.</li>
</ol>


<p>See below for an example of each of the 4 types of Props:</p>

<mws-Demo
text='
    <!-- 1. Any type, required -->
    <props
        design
        data
    ></props>

    <!-- 2. Type-checked, required -->
    <props
        design=String
        data=Array
    ></props>

    <!-- 3. Any type, optional with default -->
    <props
        design
        design.default="square"
        data
        data.default:=&apos;[1, 2, 3]&apos;
    ></props>

    <!-- 4. Type-checked, optional with default -->
    <props
        design=String
        design.default="square"
        data=Array
        data.default:=&apos;[1, 2, 3]&apos;
    ></props>
'></mws-Demo>



<h3>renderObj</h3>

<p>Props contributes it's received values to the renderObj. Examples:<p>

<ol>
    <li>Prop set like: <code>&lt;x-Btn design="round"&gt;</code> will be
    accessible on the renderObj like <code>renderObj.props.design</code>, and
    in the Script or Template CParts like <code>props.design</code>.</li>

    <li>Prop set like: <code>&lt;x-Chart data:='["a", "b"]'&gt;</code> will be
    accessible on the renderObj like <code>renderObj.props.data</code>, and
    in the Script or Template CParts like <code>props.data</code>.</li>
</ol>


<h3>Examples</h3>

<p>TODO: Need example here where you can control both "sides", both the prop
definition and use of the component.</p>


<mws-Section name="template">Template</mws-Section>

<p>The <em>Template</em> CPart allow components to render their HTML content
using a small domain-specific language, called the "templating engine". The
default engine is the <em>Modulo templating language</em> (aka "MTL"), although
that can be configured on a per-CPart basis.</p>

<p>Without a <em>Template</em> CPart (or equivalent custom code), the default
behavior of the <em>Component</em> CPart is to make no attempt to alter their
contents. However, most components require complicated HTML structures within
them. This is where Templates come into play: They generate the
<code>innerHTML</code> of a component.</p>

<p>Templates are not DOM-based, but instead render synchronously to a String
during the <code>render</code> <a
href="/docs/directives.html#lifecycle">lifecycle phase</a>, and setting that to
the <code>renderObj.component.innerHTML</code>. The <em>Component</em>  CPart
will take whatever is written there during the <code>updated</code> phase and
then "reconcile", modify it's contents to resemble the target innerHTML. (More
on this is in <a href="#component">the Component CPart documentation below</a>.)</p>


<p>Every time a Component renders, the Template will render using the
<em>renderObj</em> as a "template context", or, in other words, using the
various CPart's contributions to the <em>renderObj</em> as Template variables
that can be inserted into the HTML.  For a more discussion of Template, see
<a href="/docs/tutorial_part2.html#templating">Tutorial Part 2</a>.</p>



<mws-Section name="state">State</mws-Section>
<p>TODO</p>


<mws-Section name="state">Store</mws-Section>
<p>TODO</p>


<mws-Section name="script">Script</mws-Section>
<p>TODO</p>


<mws-Section name="style">Style</mws-Section>
<p>TODO</p>


<mws-Section name="component">Component</mws-Section>
<p>TODO</p>


<mws-Section name="module">Module</mws-Section>
<p>TODO</p>


</x-Page>
