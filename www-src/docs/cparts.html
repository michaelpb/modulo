<script src="/m.js"></script>
<x-Page
    docbarselected="cparts.html"
    pagetitle="CParts"
    navbar="docs">

<h1>CParts</h1>

<p>The central concept to Modulo is that of <em>Component Parts</em>. Because
it is so central, saying <em>Component Parts</em> over and over gets tiresome,
so it's typically shortened to <em>CParts</em>.</p>

<p>Every component definition consists of configuring one or more CPart
definitions. In fact, the <em>Component</em> CPart



<mws-Section name="spares">CPart Spares</mws-Section>

<p>If you have extra car parts lying around, you call them <em>spare
parts</em>, or just "spares". In Modulo, extra or inactive CParts are also
called Spares.</p>


<h3>Mechanics of Spares</h3>

<p>The use for this might be to have more than one <em>Template</em> that can
be switched out depending on what data model is being used, more than one
<em>State</em> to allow for both private and shared data between components, or
more than one <em>Script</em> to be swapped to quickly change behavior based on
if the user is logged in or out. Many of these things might be doable without
CPart spares, such as with if-statements, but spares provide a paradigm for
working comfortably with multiple CParts.</p>

<p>When you have duplicate CParts of the same type in a component, <em>only
one</em> CPart a time of each type is the "active" CPart, accessible in the
<code>element.cparts</code> object. That is to say, there can never be more
than one active CPart.  Both the active and extra (spare) CParts are available
in <code>element.cpartSpares</code>. Simply by assigning a property of
<code>element.cparts</code> you can select which one is active.</p>

<p>By default, the last CPart defined will be the active CPart.</p>

<p>For a concrete example, examine how the following behaves:</p>

<mws-Demo
demotype="minipreview"
text='
<template name="shop">
    <nav>Shop|<a @click:=script.swap payload="home">Home</a></nav>
    <h1>Shop</h1>
    <p>$10 - A banana</p>
</template>
<template name="home">
    <nav><a @click:=script.swap payload="shop">Shop</a>|Home</nav>
    <h1>Home</h1>
    <p>Welcome to my banana stand!</p>
</template>
<script>
    // swap: Set the active cpart by searching through the spare
    // array and selecting the one with a name matching payload:
    function swap(payload) {
        element.cparts.template = element.cpartSpares.template
            .find(({attrs}) => attrs.name === payload);
    }
</script>

<!-- some basic styling -->
<style>
nav {
    background: black;
    color: gray;
    padding: 3px;
}
a {
    color: lightblue;
    text-decoration: underline;
    cursor: pointer;
}
</style>
'></mws-Demo>


<p><strong>Note:</strong> Swapping templates should <em>not</em> be a suitable
replacement for real links or an adequate frontend routing system. In other
words, consider swapping templates as a technique only for things like
alternate themes, filter views, logged-in vs logged-out, and other such
scenarios, but not for general page navigation. This is because they break
many web standards, confuse search bots crawling for SEO, and ruin user
experience by not looking like links for accessibility purposes, having no URL,
and no effect on browser history.</p>


<h3>CPart spares and renderObj</h3>

<p>CPart spares (inactive CParts) can still influence your component, even if
they are never activated.
Specifically, they still get the <code>loadCallback</code> and
<code>factoryCallback</code> invoked, meaning they still contribute to the
<code>loadObj</code> and the <code>baseRenderObj</code> like any other CPart of
their type (<a href="/docs/directives.html#renderobj">see relevant docs on
these renderObj</a>). For some types of spares, this effectively causes them to
be "squashed" into a single renderObj.</p>


</x-Page>
