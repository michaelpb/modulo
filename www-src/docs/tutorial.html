<script src="/m.js"></script>
<load src="/components/embeddedexampleslib.html" namespace="docseg"></load>

<script>window.onload = () => Modulo.defineAll();</script>

<template modulo-embed>
    <component name="ExampleBtn">
        <props
            label
            shape
        ></props>
        <template>
            <button class="my-btn my-btn__{{ props.shape }}">
                {{ props.label }}
            </button>
        </template>
        <style>
            .my-btn {
                display: inline-block;
                box-sizing: border-box;
                font-family: sans-serif;
                border: 1px solid gray;
                transition: 0.1s;
                box-shadow:
                    inset -3px -3px
                    1px 1px rgba(100, 100, 100, 0.3);
                border-radius: 1px 8px 1px 8px;
                cursor: default;
                text-align: center;
                padding: 3px;
                padding-right: 5px;
                padding-bottom: 5px;
                height: 30px;
                background: turquoise;
                font-weight: bold;
            }

            .my-btn:active {
                box-shadow: inset 3px 3px 1px 1px rgba(100, 100, 100, 0.3);
            }
            .my-btn__square {
            }
            .my-btn__round {
                border-radius: 150px;
            }
        </style>
    </component>
</template>



<x-Page
    docbarselected="tutorial.html"
    pagetitle="Tutorial"
    navbar="docs">

<h1>Tutorial</h1>

<blockquote> <p><strong>Prerequisites:</strong> Part 1 and Part 2 of this
tutorial requires a prerequisite knowledge of HTML &amp; CSS only.  Part 3
requires familiarity with JavaScript. Familiarity with React, Vue, or similar
frameworks is helpful, but not required.</p></blockquote>

<h1>The Modulo Tutorial</h1>
<p>Welcome to the Modulo tutorial. By following this short tutorial, you can
learn how to use Modulo in your own projects.</p>
<p><strong>Ready to dive in to Web Component development with
Modulo?</strong></p>


<mws-Section name="part1">Part 1: Components, CParts, Loaders</mws-Section>

<h3>Including Modulo</h3>

<p>Modulo is useful when using plain HTML and CSS is no longer sufficient. It
has no dependencies, has no "build process", and does not require knowledge of
JavaScript, use of terminal applications, or use of NPM. This means it can be
equally easily incorporated into a plain HTML "static site" (e.g. when you
assemble HTML, CSS, and other static assets in a directory), or into a
"multi-page" web app built with a backend language or MVC framework.</p>

<p>The first step is to include the Modulo.js file. You can do this one of
3 ways:</p>

<ol>
    <li>Using a script tag to directly link to a CDN hosting the Modulo.js file
    <em>(easiest, you'll do this in the first exercise)</em></li>
    <li>Manually downloading the Modulo.js file and including it with a script
    tag, e.g.  <code>&lt;script src="/js/Modulo.js"&gt;</code> <em>(good for
    working offline, or for bundling Modulo with other JS frameworks)</em></li>
    <li>Including a "self-bundled" Modulo "build" that packs your custom
    components into a single JS file for faster load times <em>(more advanced
    usage, covered at the end of this tutorial)</em></li>
</ol>

<p>Once Modulo.js is included in a page, Modulo itself needs to be explicitly
activated. Until Modulo is activated, it <em>WILL NOT</em> register any
components or do anything at all.  Activate Modulo with the following code
placed somewhere before the closing "body" tag of your HTML file:</p>
<pre>&lt;script&gt;Modulo.defineAll()&lt;/script&gt;</pre>

<p>Alternatively, you can have it only activate after the page finishes
loading. This allows you to place the <code>script</code> tag anywhere on the
page:</p>
<pre>&lt;script&gt;window.onload = () =&gt; Modulo.defineAll()&lt;/script&gt;</pre>


<blockquote>
    <p><strong>Why use "components"?</strong> Have you ever repeated the same
    HTML, CSS, and/or JavaScript while writing a website or or web app?
    <em>Components</em> let you store repeated code in one place. Once defined,
    components can be re-used everywhere, saving developer time and reducing
    mistakes. Furthermore, within teams, components libraries improve
    collaboration between developers.</p>
</blockquote>

<h3>Defining your first component</h3>

<p>Once you have included Modulo and activated it, you can define your first
<em>custom component</em>. Right now, we'll do that "embedded" into one file
for simplicity's sake, although before the end of this section, we'll learn how
to split your components into a separate file, which is the preferred way.</p>


<p><strong>Component definitions</strong> start with a "component"
opening tag in the format of
<code>&lt;component&nbsp;name="HelloWorld"&gt;</code>. Modulo will scan a
document for these tags, defining components for each one it encounters.
Every component definition must specify a name, conventionally in
<code>UpperCamelCase</code>. This is just a convention when writing code:
Technically HTML tag names are all case insensitive, and so while inspecting
the DOM, browsers may display them in <code>all-lowercase</code>.</p>

<p>Once defined, you can use a component by referring to it's name as
though it were a plain HTML tag like &lt;div&gt;. Components can go
anywhere that plain HTML tags can go, and can be styled with CSS the same
way as well. Unlike plain HTML tags, you must use a dash (<code>-</code>)
when referring to a component. This is a rule of the HTML5 Custom
Components standard, which Modulo is based upon.</p>

<p>Modulo's default behavior is to prefix custom components with an
<code>x-</code>. So, if a component is defined like
<code>&lt;component&nbsp;name="HelloWorld"&gt;</code>, then it can be
referenced elsewhere like
<code>&lt;x-HelloWorld&gt;&lt;/x-HelloWorld&gt;</code>.</p>

<p>Finally, one more thing: When defining custom components in an HTML
document, you can't put them scattered everywhere. You have to keep them in one
place. Specifically, to keep things neater, Modulo searches for component
definitions only within a <code>modulo-embed</code> tag:
<code>&lt;template modulo-embed&gt;</code></p>

<p>To quickly summarize: Components are reusable bits of HTML, JS, and CSS
code, and must be defined within a tag like
<code>&lt;component&nbsp;name="HelloWorld"&gt;</code>, and then this definition
can be embedded in an HTML page within a tag like
<code>&lt;template&nbsp;modulo-embed&gt;</code>.</p>

<p><strong>Okay, enough talk, let's actually try this out!</strong></p>


<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <ol>
        <li>Open up an HTML file in your preferred text editor. It's okay
        to start from scratch, or use an existing project.</li>
        <li>Copy &amp; paste in the following code:

<mws-Demo
text='
<!-- Define a custom component in a "modulo-embed" -->
<template modulo-embed>
    <component name="HelloWorld">
        <template>
            Hello <strong>Modulo</strong> World!
        </template>
    </component>
</template>

<!-- Reuse it anywhere, just like any other HTML tag -->
<div>
    <x-HelloWorld></x-HelloWorld>
    <p>In a P tag: <x-HelloWorld></x-HelloWorld></p>
</div>

<!-- Finally, include a Modulo CDN link & activate (at the bottom) -->
<script src="https://modulojs.org/js/Modulo.js"></script>
<script>Modulo.defineAll();</script>
'></mws-Demo>
</li>
<!--<script src="https://cdn.skypack.dev/modulo?min"></script>-->
        <li>Ensure that the HTML file is opened in your preferred, modern web
        browser (such as Firefox or Chrome) as well.</li>
        <li>Refresh your web browser to view the results.</li>
    </ol>
</section>


<h3>Introducing: Component Parts</h3>

<p>The central concept to Modulo is that of <em>Component Parts</em>.
Because it is so central, saying <em>Component Parts</em> over and over
gets tiresome, so it's typically shortened to <em>CParts</em>.</p>

<blockquote> <p><strong>CParts: The Musical</strong> Think of CParts like the
cast and crew of a musical. Each are assigned to a different task&mdash;some
are more flashy and visible, others being stage-hands working behind the
scenes&mdash;but they all work together to put on the same
show!</p></blockquote>

<p>All component definitions consist of some number of CParts.  Thus, a
component definition is really just a collection of CPart definitions.
"Under the hood" of your component, each CPart will have a different role
to contribute to the functionality of your component.</p>

<!--<p> When a component definition is later instantiated (i.e., when that
component is used on the page), Modulo will in turn instantiate (i.e.
create an instance of) a CPart for each of the CPart definitions contained
in the component definition.</p>-->

<p>Let's start with the two most basic CParts:</p>
<ol>
    <li>
        <strong>Template</strong> - <code>&lt;template&gt;</code>
        <p>Templates are where you put any arbitrary HTML code that you
        want your component to contain. For now, we'll just include some
        unchanging HTML. Later, we'll learn how to use "templating
        language" to control what HTML is produced in what
        circumstance.</p>
    </li>

    <li>

        <blockquote> <p><strong>Where to put CSS</strong> Instead of a
        Style CPart, you can always link a global CSS file the regular way
        to style your components.  However, many developers prefer the
        simplicity of keeping everything in one place, e.g. the CSS with
        the component definition that it styles.</p></blockquote>

        <strong>Style</strong> - <code>&lt;style&gt;</code>
        <p>Just like the <code>&lt;style&gt;</code> tag in HTML, the
        <strong>Style</strong> CPart allows us to write CSS for our
        component. CSS written here will be automatically prefixed so that
        it will only apply to your component and any HTML generated by the
        Template CPart.
        </p>

    </li>
</ol>

<p>Throughout Modulo documentation, there are little code editors, like below.
These allow you to immediately practice new concepts learned. For simplicity,
the top and bottom of the component definition code is omitted.  Instead, these
sample code editors only focus on the CPart definitions within.</p>

<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Edit the component definition on the left, and click RUN to see the
    results on the right!</p>

    <ol>
        <li>Practice modifying the <strong>Template</strong> CPart
        (<code>&lt;template&gt;</code>) to see how that affects the
        output</li>
        <li>Practice modifying the <strong>Style</strong> CPart
        (<code>&lt;style&gt;</code>) to add or modify CSS</li>
        <li>Practice incorporating these CParts into your own components on
        a real page by copying the code here and pasting it within your
        component definition (that is, the one that you created in the
        previous part of this tutorial)</p>
    </ol>
    <mws-Demo
        demotype="minipreview"
        fromlibrary="Tutorial_P1"
    ></mws-Demo>
</section>


<h3>Modulo Loader</h3>

<p>Up until now, we have practiced with a component embedded on the same
page that it is used. This is not recommended. Instead, you should put your
components in a separate file, and then use the
<code>&lt;load&gt;</code> tag to import your components into every
HTML file that needs them.</p>


<blockquote> <p><strong>Why use load?</strong>
Think of the <code>&lt;load&gt;</code> tag as being analogous to the
<code>&lt;link&gt;</code> tag, which lets multiple HTML files share the
same CSS. The same rationale applies here: Components are "write once, use
everywhere", so the way we get access to them "everywhere" is by
<em>loading</em> them into each file that needs to use them.  Another
reason: <code>&lt;load&gt;</code> smooths over certain browser
limitations.</p>
</blockquote>

<p>Loader tags look like the following:</p>

<pre>
&lt;load
    src="./components/my-stuff.html"
    namespace="coolstuff"&gt;
&lt;/load&gt;
</pre>

<p>Let's break this down:</p>
<ul>

    <li>
        <code>src="./components/my-stuff.html"</code>
        <p>The <code>src</code> attribute specifies the source of the
        component library file. This file can be anywhere that is
        accessible to your web-browser or web-server. Ideally, it should be
        in the same place as your CSS and static media files, such as a
        <code>static/</code> directory, or whatever the equivalent is for
        your set-up.</p>
        <p>The component library itself (<code>my-stuff.html</code> in this
        example) should consist of an HTML file filled with
        <code>&lt;component&gt;</code> definitions.</p>
    </li>

    <li>

        <blockquote>
        <p><strong>Why use namespaces?</strong>
        Namespaces allow different component library files to have
        conflicting component names. This is especially useful when using
        third-party component libraries or while working in a big team:
        That way, if both you and another developer define a component with
        some common name (eg <code>name="Button"</code>), there won't be a
        conflict as long as you load each into different namespaces.</p>
        </blockquote>

        <code>namespace="coolstuff"</code>
        <p>The <code>namespace</code> attribute specifies the
        <em>namespace prefix</em>, which is combined with a dash and the
        component name in order to create the component's <em>full
        name</em>. </p>
        <p><strong>Example:</strong> If <code>my-stuff.html</code> has a component
        defined like <code>&lt;component name="MyThing"&gt;</code>
        imported with <code>namespace="coolstuff"</code>, then the
        resulting full name would be <code>coolstuff-MyThing</code>, and
        we'd use the component like<br />
        <code>&lt;coolstuff-MyThing&gt;&lt;/coolstuff-MyThing&gt;</code>.</p>
    </li>


    <li><strong>Where to put it:</strong> Loaders can go anywhere. For
    neatness, consider putting them either within the
    <code>&lt;head&gt;</code> tag, or near the <code>&lt;/body&gt;</code>
    closing tag.</li>
</ul>


<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>It's time to "promote" your beginner embedded component into a
    full-fledged loaded component!</p>
    <ol>
        <li>Optional: Create a new "components" directory to house your
        component library files.</li>
        <li>Create a new file for your component library within your
        components directory (or elsewhere). You could call it, for
        example, <code>my-component-lib.html</code></li>
        <li>Copy your existing <code>HelloWorld</code> component definition
        from your main HTML file into this new file, and then delete it
        from your main HTML file. If done correctly, your new component library
        file (e.g. <code>my-component-lib.html</code>) should contain the
        following text (note the lack of "modulo-embed"):
<mws-Demo
text='
<component name="HelloWorld">
    <!-- ... snip ... -->
</component>
'></mws-Demo></li>

        <li>Add a <code>load</code> tag to your main HTML file. It
        should have the <code>src=</code> attribute pointing toward a
        relative path to your new component library file, and namespace can
        be <code>lib</code>.  For example, if you named everything based on
        the above suggestions, it would look like this:
<mws-Demo
text='
<template modulo-embed>
    <load
        src="./components/my-component-lib.html"
        namespace="lib"
    ></load>
</template>
'></mws-Demo></li>

</li>

        <li>Finally, update your main HTML file's usage of the component to now
        use the new namespace (instead of the "x" default namespace
        placeholder):
<pre>
&lt;lib-HelloWorld&gt;&lt;/lib-HelloWorld&gt;
&lt;p&gt;In a P tag: &lt;lib-HelloWorld&gt;&lt;/lib-HelloWorld&gt;&lt;/p&gt;
</pre></li>
        <li>Refresh the web browser to view the results. If done correctly,
        nothing should change. To confirm it's working, try editing your
        component in the library file and refresh to see the results.</li>
    </ol>

    <p><strong>Bonus Challenge:</strong>
    Try practicing with multiple "main HTML" files sharing the same
    component library. Also, if you used the example name, consider renaming
    your component library. Consider naming it something that is relevant to
    you, e..g "ecommerce-website-components" or something, whatever you think
    is a good name based on what you are working on. Finally, practice changing
    the namespace, or see if you can cause (and fix using the namespace
    attribute) a naming conflict with two components.</p>

</section>


<h3>Part 1: Summary</h3>

<p>In this tutorial, we learned what a <em>Component</em> is, and how to
define one, about what <em>CParts</em> are, and two important CParts
(<em>Template</em>, for HTML, and <em>Style</em>, for CSS), and finally how
to keep our components in a component library and then load that library
into different HTML files. At this point, you can already start getting
useful results from using Modulo, since even without JavaScript usage we
are already defining simple components that can help us re-use HTML code
between different pages.</p>


<h4>Key terms</h4>

<ul>
<li> <strong>Component</strong> - A discrete, re-usable bit of code, typically
used to show a graphical UI element (eg a button, or a rich-text area).
Components can also use other components (eg a form component might contain
both of the above as child components).  </li>

<li>ComponentPart, or <strong>CPart</strong> - Each component consists of a
"bag" or "bundle" of CParts, each CPart being a "pluggable" module that
supplies different functionality for that component.  Every component is
defined as a collection of CParts (e.g.  HTML <em>Template</em>, or
<em>Style</em> tag).</li>

<li><strong>customElement</strong> - The term used for a custom HTML5 web
component, which is the underlying technology that Modulo is a thin wrapper
over. They all have dashes (<code>-</code>) in the name.</li>
</ul>



<p>In the subsequent tutorials we will go deeper: Explore the full
capabilities of Templates, allow flexible and composable components with
Props CPart, create custom behavior with Script CParts,  and finally create
forms and interactive, changing components with the State CPart.</p>




<mws-Section name="part2">Part 2: Props and Templating</mws-Section>


<h3>CPart: Props</h3>

<p>In the previous section, we were mostly concerned with <em>defining
components</em>. Recall that components are defined once, but can be used many
times.
The purpose of <em>Props</em> is to allow more flexibility in that second step:
<em>Props</em> CPart defines the <em>properties</em> that can be customized
about a component each time it is reused.  Thus, to start our discussion of
<em>Props</em> we'll first get more practice reusing components.</p>

<h4>Other people's components</h4>

<p>Before we learn how to use the <em>Props</em> CPart itself, let's first get
acquainted with a concept we haven't done before: Reusing components that were
coded by someone else! In a realistic scenario of an organization building a
web app, it's likely that most of the components you will be using won't
actually be written by you personally, but instead by someone else on some sort
of internal "component library" team.  Similarly, even if working by yourself,
you'll need to learn how to component libraries written by others so you can
use components already defined for you to accomplish common tasks. Don't
reinvent the wheel!</p>

<p>In this next activity, we'll practice reusing components.</p>

<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Context: The <code>&lt;x-ExampleBtn&gt;</code> button component has
    already been defined for you. It was defined to accept two so-called
    <em>"props"</em>: <code>label</code>, and <code>shape</code>. We'll cover
    how it was defined to use a <em>Props</em> CPart later on. For now, we'll
    practice only with using the <code>x-ExampleBtn</code>.</p>

    <ol>
        <li>Examine the code below. Examine the preview on the right. Do you
        see how the code in turn uses the <code>x-ExampleBtn</code> in two
        locations, with a different shape and label each? We can call each of
        these a <em>component instance</em>. Each component instance can
        receive different or customized <em>props</em> attributes.</li>

        <li>Note the <code>label="..."</code> prop attribute that is on each
        <code>x-ExampleBtn</code>. Test it out by editing the contents of this
        attribute on one or both of the buttons and click RUN to see the result
        on the right.</li>

        <li>Note the <code>shape="..."</code> prop that is on each button. It's
        impossible to have known this without reading the CSS of
        <code>x-ExampleBtn</code>, but it accepts either "square" or "rounded".
        Try changing one to the other and see the results.</li>
    </ol>

    <mws-Demo
        demotype="minipreview"
        fromlibrary="Tutorial_P2"
    ></mws-Demo>

    <p><strong>Comprehension Challenge 1:</strong> Based on the patterns you see
    here, add a third button to this example that is round and contains the
    word "Hello".</p>
    <p><strong>Comprehension Challenge 2:</strong> See if you can think up what
    props might be attached to different types of widgets, e.g. a "modal
    pop-up" widget might specify the title, or an Open Street Map widget might
    specify latitude and longitude for the map being displayed. What would a
    text input need? What about a tabbed navigation interface? How about a
    component that shows a chess board with pieces in a specified setup?</p>
</section>


<blockquote> <p><strong>Why use Props?</strong>
Components are "write once, use everywhere". That is to say, you only need to
define a component once to use it throughout your pages. The advantages of
"write once, use everywhere" are clear: By writing "DRY" (non-repetitive)
code, you can make changes to the single component definition and see those
changes take effect wherever that component might be used.
However, sometimes you want each instance of a component to have different
content or modified behavior. This is where <em>Props</em> come into play: They
allow you to customize differences in content or behavior between multiple uses
of the same component.</p>
</blockquote>


<h4>Defining props</h4>

<p>Let's "peel back the layers" and examine out how this ExampleBtn was
written.</p>

<p>In order for a component to be able to "receive" props when it is reused, we
must define a <em>Props</em> CPart, which is conventionally placed as the first
thing in a component definition. <em>Props</em> CParts are defined somewhat like
previous CParts, except they have no contents and are just an opening tag with
attributes, followed by a closing tag. A <em>Props</em> CPart might look like
this:</p>

<pre>&lt;props name device frequency&gt;&lt;/props&gt;</pre>

<p>The recommended style for Modulo code is to add a newline after each prop
name for easier reading. HTML syntax doesn't care either way, so the above
might be improved for readability if it were written as follows:</p>

<pre>
&lt;props
    name
    device
    frequency
&gt;&lt;/props&gt;
</pre>


<p>Once you have defined which props you expect a component to receive by using
the <em>Props</em> CPart, you can then reference the values of those props
elsewhere within the component: Either in the <em>Template</em> CPart (what
we'll cover next), or in the <em>Script</em> CPart (covered later).</p>

<hr />

<h3>Templating</h3>


<blockquote> <p><strong>Can I use props in CSS?</strong>

<p>No. Note that the <em>Style</em> CPart intentionally does not support
template substitution, or any such "live" modification whatsoever. If you want
to directly insert props as CSS values, this should be done in the template by
using an inline <code>style=</code> attribute. For more complicated CSS
transformations, consider setting CSS variables on the <code>style=</code>
attribute that are then used by the <em>Style</em> CPart, by using the
<code>var()</code> CSS function.</p>
</blockquote>

<p>Our discussion of props gives us a chance to explore the <em>Template</em>
CPart a little bit deeper. Previously, we have only used a <em>Template</em>
CPart to display static, unchanging HTML. That's quite limiting. The typical
purpose of "templating" or "a templating language" is to allow customization,
substitution, and transformation of HTML content.  Templating isn't unique to
web development: If you've used template files with word processors such
Microsoft Word, or email templates within marketing or sales software, you'll
know that with templating you can include placeholders where we want to insert
data or values, in order to personalize each instance.</p>



<h4>Using props within a template</h4>

<p>Within a <em>Template</em> CPart, we can insert data or values using a
special "placeholder" syntax that is as follows:
<code>{{&nbsp;myVariableName&nbsp;}}</code>.
We can also use a dot (".") in this syntax to access properties.
Thus, you will see this placeholder syntax more often used like this:
<code>{{ props.device }}</code>. So, combining this information with the 3
props that we have above, we can create a template that has 3 placeholders that
get filled in with specific data when the component gets reused. Examine the
below code and try to guess at what it might do:</p>

<pre>
&lt;template&gt;
    Hi {{ props.name }}, your {{ props.device }} is at {{ props.frequency }}hz.
&lt;/template&gt;
</pre>

<p>In this case, if we were to use our component with the attributes
<code>name="Tux"</code>, <code>device="Radio"</code> and
<code>frequency="2600"</code>, then the following text would be rendered:
<code>Hi Tux, your Radio is at 2600hz.</code></p>


<p>The "Modulo templating language" was modeled after Django, Jinja2, or
Liquid, and thus is quite powerful, being capable of much than the simple
substitutions we're learning here. We'll learn more features later.</p>


<h4>Combining props with template HTML</h4>

<p>In the previous example, we showed how text can be rendered using
substitutions. Next let's see how such substitutions can be used to generate
more complex HTML code.</p>

<p>Examine the following component definition. This component definition is the
same definition for the <code>x-ExampleBtn</code> that was referenced in the
previous challenge:</p>

<mws-Demo
text='
<component name="ExampleBtn">

    <props
        label
        shape
    ></props>

    <template>
        <button class="my-btn  my-btn__{{ props.shape }}">
            {{ props.label }}
        </button>
    </template>

    <!-- (Note: The <style> CPart was omitted for simplicity) -->
</component>
'
></mws-Demo>


<p>At this point, we can finally begin to understand the
<code>&lt;x-ExampleBtn&gt;</code> component that we were using previously. In
this case, the value of the <code>label="Example Button"</code> prop gets
inserted as the text content of the button element, and the
<code>shape="round"</code> prop value gets inserted in the <code>class=</code>
attribute of the button element.  Thus, if the shape prop receives the value of
"round", the button gets the CSS class of <code>.my-btn__round</code>, and
similarly if it received the value of "square", it'd get the class
<code>.my-btn__square</code>. These CSS classes, as you may have guessed, are
what controls the look of the button, either giving it rounded edges or a more
rectangular, towering look.</p>


<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Okay, let's take this new concept and apply it to our previous
    HelloWorld component. Go back to the project you were working on
    previously, and follow these steps to practice adding props to your
    component:</p>
    <ol>
        <li>Examine your <code>HelloWorld</code> component definition. Near the
        top, just below the "&lt;component..." opening tag, add a
        <em>Props</em> CPart, just like the examples before.</li>
        <li>Experiment with specifying props. For example, to keep building
        this tutorial app, give it the props of <code>goal</code> and
        <code>amount</code>.</li>

        <li>If done correctly, your component definition will start something
        like this:
<mws-Demo
text='
<component name="HelloWorld">
    <props
        goal
        amount
    ></props>
    <!-- ... snip ... -->
</component>
'></mws-Demo>
        </li>

        <li>Update the template to now use these props somewhere. For the
        tutorial example, we'll be building a little "clicker" that will count
        up to a number (the "goal") by an increment amount (the "amount"). So,
        for now, let's just display the goal prop and amount prop:</li>
<mws-Demo
text='
<template>
    Hello <strong>Modulo</strong> World!
    <p>Goal: {{ props.goal }}</p>
    <p>Amount: {{ props.amount }}</p>
</template>
'></mws-Demo>

        <li>Refresh the web browser to view the results. Assuming you still
        have the component displaying somewhere on your page, if done
        correctly, you will see your component update to reflect the changes
        you made to your template, possibly something  like "Goal: undefined"
        and "Amount: undefined".</li>

        <li><strong>Comprehension question: If you see the text "undefined",
        why do you think that is?</strong></li>

        <li>Answer: If you are seeing "undefined", it's probably because you
        are not passing in the Props that are required.</li>

        <li>To fix this, we need to specify the props in the location where we
        are <em>reusing</em> or actually displaying the component on the page.
        This is done by adding attributes with the names "goal" and "amount" to
        the component tag instances.</li>

        <li>If you have made a lot of changes since <em>Part 1</em> of this
        tutorial or did not follow the naming suggestions, your code may end
        looking different than this. However, if that's not the case, your code
        might end up looking like this:
<mws-Demo
text='
<div>
    <x-HelloWorld
        goal="10"
        amount="2"
    ></x-HelloWorld>
    <p>In a P tag:
        <x-HelloWorld
            goal="10"
            amount="2"
        ></x-HelloWorld>
    </p>
</div>
'></mws-Demo>

        </li>
    </ol>

    <p><strong>Bonus Challenge:</strong> Read ahead about <em>template
    filters</em>, and try using those here.</p>
</section>


<h3>Template filters</h3>

<p>The Modulo templating language has two more big features: <em>filters</em>
(for formatting values), and <em>templatetags</em> (for control-flow). We'll
briefly introduce <em>filters</em> now, but for a more thorough introduction to
the Modulo templating language, you should <a href="/docs/templating.html">read
the Templating section</a>.</p>

<p>Template <em>filters</em> format or otherwise transform template variables.
The template filter syntax consists of taking a template variable and adding a
vertical bar followed the name of a filter (e.g.
<code>varName|filterName</code>). The following example will transform the text
contained in the <code>props.name</code> template variable to make it all
uppercase:</p>

<pre>Hello {{ props.name|upper }}</pre>

<p>Some filters can also take extra modifiers or options. This is called the
template filter <em>argument</em>. Do you recall how our previous ExampleBtn
component only supported either "round" or "square" as CSS classes? In this
next example, we are going to use the <code>|allow</code> template filter to
ensure that only "round" or "square" are permitted: </p>

<pre>&lt;button class="my-btn my-btn__{{ props.shape|allow:"round,square" }}"&gt;
    (... snip ...)
&lt;/button&gt;</pre>

<p>Note how the argument is separated from the filter with a colon: The general
syntax is <code>varName|filterName:"argument"</code>. Thus, the
<code>|allow:"round,square"</code> filter instructs Modulo to <em>only</em>
output the property of <code>props.shape</code> if it exactly matches the text
"round" or "square".</p>

<p>You can do more than this with filters: You can string together the dozens
of available filters for more powerful combinations, and by using JavaScript
script tags (covered in Part 3) you can easily author your own.
The full <a href="/docs/templating-reference.html">Templating Reference</a> has
examples of all filters available.</p>

<!--
<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <p>Edit the component definition on the left, and click RUN to see the
    results on the right!</p>

    <ol>
        <li>Practice modifying the <strong>Template</strong> CPart
        (<code>&lt;template&gt;</code>) to see how that affects the
        output</li>
        <li>Practice modifying the <strong>Style</strong> CPart
        (<code>&lt;style&gt;</code>) to add or modify CSS</li>
        <li>Practice incorporating these CParts into your own components on
        a real page by copying the code here and pasting it within your
        component definition (that is, the one that you created in the
        previous part of this tutorial)</p>
    </ol>
    <mws-Demo
        demotype="minipreview"
        fromlibrary="Tutorial_P2_filters_demo"
    ></mws-Demo>
</section>
-->


<h3>Modulo build: Packing it up</h3>



<blockquote> <p><strong>Why build?</strong>
Let's start with a "thought experiment", where we fast forward into the
future. Imagine that as you create more and more components, you begin
splitting them up into more component libraries. Also, as mentioned previously,
perhaps you find some nice component libraries that others have made that you
want to use in your project. In the end, you might find yourself with dozens of
HTML files being loaded, scattered in different directories.
</p>

<p>In this situation you will have too many <code>&lt;load&gt;</code> tags,
meaning your page may take a long time to start-up.  As it's downloading all
the different files, the browser will be showing the ugly, unformatted text in
the mean-time.  On slow connections, this could be end up being a frustrating
experience for users. This is why building to one file is useful.</p>
</blockquote>

<p>We've got one more topic for <em>Part 2</em> of the Modulo tutorial: Packing
or bundling your component library for production.</p>


<h4>Intro to building</h4>


<p>"Building" is a feature of Modulo where it will pack up all the components
you have loaded on a particular page, mix in it's own source code, and spit out
a single JS file. This single JS file, called a <em>build</em>, will contain
all the code from all your components. You can then comment out or delete the
<code>&lt;load&gt;</code> tags, since this one JS file will be all you need.
Generally, developers create builds before "launching" their site to
"production" (e.g. publishing their site for the world to see), since it
results in the fastest possible loading time.</p>

<p>To build a project, we will need to run a <em>Modulo Console Command</em>.
The <em>console</em> is a feature of all web browsers. As a web developer you
likely have used it: It's a panel, hidden by default, where JS, CSS, and other
such error messages are displayed. While most JS frameworks use complicated
NPM-based tools to build,  Modulo can be built right from your browser's
console, simply by typing <code>m.build</code> and hitting enter.</p>



<section class="Tutorial-tryit">
    <h4>Try it now</h4>
    <ol>
        <li>Open up your HTML file in your browser (e.g. Firefox or
        Chrome/Chromium). Do not open your component library HTML files: Be
        sure to open the file that <em>is doing the importing</em> and
        <em>using the components</em>, not the file(s) that contain the
        component definitions themselves.</li>

        <li>Bring up the console: Press <code>Control+Shift+J</code> (Linux,
        Windows) or <code>Command+Option+J</code> (macOS) on your keyboard to
        open the Console.  Alternatively, you can right-click with your mouse
        and select "Inspect", and then go to the <em>Console</em> tab.</li>

        <li>Within the newly opened console, type <code>m.build</code> and hit
        enter.</li>

        <li>It should now offer to download a single JS file that contains both
        Modulo.js and all your component code! Save this JS file somewhere,
        such as in a "js" directory, or next to the HTML file that you have
        open in your browser.</li>

        <li>Now, let's practice updating our HTML file to use the bundle. You
        can comment out all of your previous loading code and script tags,
        since this 1 bundle file will replace all of those. The end result
        might look something like this:
<mws-Demo
text='
<!-- Comment out old loading code:
<template modulo-embed>
    <load src="./components/my-component-lib.html" namespace="lib" ></load>
</template>
<script src="https://modulojs.org/js/Modulo.js"></script>
<script>Modulo.defineAll();</script> -->

<!-- Add in built JS file (Remember: Ensure the path is correct!) -->
<script src="./modulo-build.(some hash goes here).js"></script>

<!-- Now, the components we define can be used just like before: -->
<div>
    <x-HelloWorld goal="10" amount="2" ></x-HelloWorld>
    <p>In a P tag: <x-HelloWorld goal="10" amount="2" ></x-HelloWorld> </p>
</div>
'></mws-Demo></li>
    </ol>

    <p><strong>Important: Undo it all!</strong> Before going on to Part 3 of
    this tutorial, remember to switch back to using the load tag, e.g.
    essentially reversing all of the steps above. This is because you will
    continue to edit this component library as part of the tutorial. The build
    "freezes" the component library in time, and you'll have to run build again
    if you change anything.  A common mistake is forgetting that you are
    editing the original <code>.html</code> file while using the built
    <code>.js</code> version, causing much confusion as to why your changes
    don't take effect!</p>

</section>

<mws-Section name="part3">Part 3: State and Script</mws-Section>

coming soon!



</x-Page>
