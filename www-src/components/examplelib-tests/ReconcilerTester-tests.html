<test name="ensure ModRec and MTL are defined">
    <script>
        Modulo.utils.makeMockElement = function reconcile (html)  {
            const {makeDiv} = Modulo.utils;
            const mockElement = makeDiv(html);
            mockElement.applyDirectives = () => {}; // dummy
            mockElement.resolveValue = () => () => {}; // dummy(2)
            return mockElement;
        }
        Modulo.utils.getRecPatches = function reconcile (oldHTML, newHTML)  {
            const {makeDiv} = Modulo.utils;
            const mockElement = Modulo.utils.makeMockElement(oldHTML);
            const modRec = new ModRec(true);
            modRec.reconcile(mockElement, newHTML, true); // skip old
            return modRec.patches;
        };
        Modulo.utils.patchStringify = function patchStringify (patch)  {
            const [node, method, arg1, arg2] = patch;
            return `<${node.nodeType} ${node.nodeName}> ${method}("${arg1}", "${arg2}") </${node.nodeType}>`
        }
        Modulo.utils.pToString = function patchStringify (patches)  {
            return patches.map(Modulo.utils.patchStringify).join('\n')
        }
        Modulo.utils.anchorInTheDeep = function anchorITD (html)  {
            return `
                <div>
                    <div id="main"><p>A<p><p>B</p></div>
                    <div class="other section">
                      <p>A<p><p>B</p>
                    </div>
                    <footer><a href="#">${html}</a></footer>
                </div>
            `;
        }


        const {ModRec} = Modulo.reconcilers;
        assert: ModRec
    </script>
    <script>
        const {MTL} = Modulo.templating;
        assert: MTL
    </script>
</test>

<test name="Patches get generated as expected">
    <script name="Text node is updated correctly">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<p>Test</p>', '<p>Test2</p>');
        const expected = '<3 #text> node-value("Test2", "undefined") </3>';
        assert: patches.length === 1 && patchStringify(patches[0]) === expected;
    </script>

    <script name="Text node is appending correctly">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<p>Test</p>', '<p>Test</p> Stuff');
        const expected = '<1 DIV> append("[object Text]", "undefined") </1>';
        assert: patches.length === 1 && patchStringify(patches[0]) === expected;
    </script>

    <script name="Adds single attribute">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<p>Test</p>', '<p id="stuff">Test</p>');
        const expected = '<1 P> setAttribute("id", "stuff") </1>';
        assert: patches.length === 1 && patchStringify(patches[0]) === expected;
    </script>

    <script name="Changes a single attribute">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<p id="stuff">Test</p>', '<p id="s t u f f">Test</p>');
        const expected = '<1 P> setAttribute("id", "s t u f f") </1>';
        assert: patches.length === 1 && patchStringify(patches[0]) === expected;
    </script>

    <script name="Deletes a single attribute">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<p id="stuff">Test</p>', '<p>Test</p>');
        const expected = '<1 P> removeAttribute("id", "undefined") </1>';
        assert: patches.length === 1 && patchStringify(patches[0]) === expected;
    </script>

    <script name="Correctly generates no patches (1)">
        const {getRecPatches, patchStringify} = Modulo.utils;
        const patches = getRecPatches('<P   >Test</p >', '<p>Test</p>');
        assert: patches.length === 0
    </script>


    <script name="Correctly generates no patches (2)">
        const {getRecPatches, patchStringify} = Modulo.utils;

        // TODO: Think of ways to "fuzz" test it by running large HTML
        // files through it to themselves, and forcing it to descend (not
        // use isSameNode).
        const str = `
            <div>abc<!-- hm --></div> <!--<p></p>--> <div a="asdf">def</div>
            <div v="asdf">hij<p></p><p></p>nm</div> <div>jkl</div> zxcvb
            <p>bnm</p> &amp; <!-- okay --><li>i<li>ii<li>iii
        `;
        const patches = getRecPatches(str, str);
        assert: patches.length === 0
    </script>

    <script name="Correctly generates no patches (3)">
        const {getRecPatches, patchStringify, anchorInTheDeep} = Modulo.utils;
        const str = anchorInTheDeep('  <I  a=b c=d>o\nk</i> ');
        const patches = getRecPatches(str, str);
        assert: patches.length === 0
    </script>

    <script name="Generates no patches when fuzz testing against loaded files">
        const {getRecPatches, pToString} = Modulo.utils;
        let msg = '';
        let inequalCount = 0;
        for (const [key, value] of Object.entries(Modulo.fetchQ.data)) {
            msg += `Doing ${key} ---\n`;
            let patches = getRecPatches(value, value);

            /*
            // NOTE: It will / should generate directives patches since this is first mount
            // Should uncomment and ensure correct logic
            if (value.includes(':=') || /\s@\w+/.test(value)) {
                if (patches.length < 1) {
                    inequalCount++;
                    msg += `${key} FAILURE Expected directive mounts: --- ${pToString(patches)}\n`;
                }
            }
            */
            patches = patches.filter(patch => !patch[1].startsWith('directive'));
            if (patches.length > 0) {
                inequalCount++;
                msg += `${key} FAILURE --- ${pToString(patches)}\n`;
            }
        }
        //console.log(msg);
        assert: inequalCount === 0
    </script>
</test>

<test name="Patches get generated in expected ways in different DOM contexts">
    <script name="Finds deep patchs as well as shallow patches">
        const {getRecPatches, patchStringify, anchorInTheDeep} = Modulo.utils;
        const str1 = '<main></main>';
        const str2 = '<main class="test">stuff</main><div novalue>other</div>';
        const str1deep = anchorInTheDeep(str1);
        const str2deep = anchorInTheDeep(str2);
        const patches1 = getRecPatches(str1, str2);
        const patches2 = getRecPatches(str1deep, str2deep);
        const patches3 = getRecPatches(anchorInTheDeep(''), str2deep);
        const patches4 = getRecPatches('', str2);
        element.patches1 = patches1.map(patchStringify).join('\n');
        element.patches2 = patches2.map(patchStringify).join('\n');
        element.patches3 = patches3.map(patchStringify).join('\n');
        element.patches4 = patches4.map(patchStringify).join('\n');
        assert: element.patches1 && element.patches2
                  && element.patches3 && element.patches4;
    </script>

    <script name="which generated different patches due to A vs DIV">
        const {patches1, patches2} = element;
        assert: patches1 !== patches2
    </script>

    <script name="but if A vs DIV is corrected then it generates same">
        const {patches1, patches2} = element;
        const correctedPatches2 = patches2.replace('A>', 'DIV>')
        //console.log(patches1, '\n\n\n--\n\n\n----\n\n\n',correctedPatches2);
        assert: patches1 === correctedPatches2 
    </script>

    <script name="and nothing to something is same no matter dom ctx (1)">
        const {patches3, patches4} = element;
        //console.log(patches3, '\n\n\n--\n\n\n----\n\n\n', patches4);
        assert: patches3 !== patches4 // because of A vs DIV
    </script>

    <script name="and nothing to something is same no matter dom ctx (2)">
        const {patches3, patches4} = element;
        //console.log(patches3, '\n\n\n--\n\n\n----\n\n\n', patches4);
        assert: patches3.replace(/A>/g, 'DIV>') === patches4;
    </script>

</test>


<test name="Applying patches">
    <script name="Generates single patch for single-rooted tree (1)">
        const {getRecPatches, pToString} = Modulo.utils;
        element.targetStr = `<div><p id="example1">Hello patching world!</p>
                    <p class="example2">Testing <em>nested</em> levels</p></div>`;
        // Should be length 1 since it's 1 node and has no directives
        element.patches = getRecPatches('', element.targetStr);
        //console.log('this is element', element.patches[0][0], element.patches[0][0].innerHTML);
        assert: element.patches
                && element.patches.length === 1
                && element.patches[0][0].tagName === 'DIV'
    </script>

    <script name="Patches apply (1)">
        const {makeMockElement, pToString} = Modulo.utils;
        const {ModRec} = Modulo.reconcilers;
        const {patches, targetStr} = element;
        const mr = new ModRec();
        mr.element = patches[0][0]; // get element out of 0th
        patches.map(patch => mr.applyPatch.apply(mr, patch))
        let results = mr.element.innerHTML.trim();
        assert: results === targetStr.trim();
    </script>

    <script name="Generates single patch for single-rooted tree (2)">
        const {ModRec} = Modulo.reconcilers;
        const {makeDiv, makeMockElement, pToString, anchorInTheDeep} = Modulo.utils;
        element.targetStr2 = anchorInTheDeep(
                    `<div><p id="example1">Hello patching world!</p>
                    <p class="example2">Testing <em>nested</em> levels</p></div>`);

        const mockElement = makeMockElement(anchorInTheDeep(''));
        const modRec = new ModRec(true);
        modRec.reconcile(mockElement, element.targetStr2, true); // skip old
        element.patches2 = modRec.patches;
        element.mockElement = modRec.element; // ensure has element interface
        // Should be length 1 since it's 1 node and has no directives
        assert: element.patches2
                && element.patches2.length === 1
                && element.patches2[0][0].tagName === 'A'
    </script>

    <script name="Patches apply (2)">
        const {makeMockElement, pToString} = Modulo.utils;
        const {ModRec} = Modulo.reconcilers;
        const {patches2, targetStr2, mockElement} = element;
        const mr = new ModRec();
        mr.element = patches2[0][0]; // get element out of 0th
        patches2.map(patch => mr.applyPatch.apply(mr, patch))

        // Ensure results are the same (normalized by wrapping in DOM element)
        let results = mockElement.innerHTML;
        const target = makeMockElement(targetStr2).innerHTML;
        assert: results === target;
    </script>

</test>

