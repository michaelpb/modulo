<Component name="MirrorEditor" rerender="manual">
    <Props
        value
    ></Props>
    <Template>
        <div class="editor-wrapper" @click:=script.updateScroll>
            <div class="editor-underlay-container"
                style="
                    {% if state.width %}  width: {{ state.width }}px; {% endif %}
                    {% if state.height %} height: {{ state.height }}px; {% endif %}
                ">
                <div class="editor-underlay-offset-wrapper"
                    style="
                        {% if state.scrollTop %} top: -{{ state.scrollTop }}px; {% endif %}
                        {% if state.width %} width: {{ state.width }}px; {% endif %}
                    ">
                    <pre class="editor-shadow">{{ state.editorShadowHtml|safe }}</pre>
                    <!--<slot name="underlay"></slot>-->
                    <!--<slot name="overlay"></slot>-->
                </div>
            </div>

            <textarea
                [script.text]
                @scroll:=script.updateScroll
                spellcheck="false"
                data-gramm="false"
            ></textarea>
        </div>
    </Template>

    <State
        selection-start:=0
        scroll-ratio:=0
        scroll-top:=0
        width:=0
        height:=0
        last=""
        editor-shadow-html=""
        value=""
    ></State>

    <Script>
        const SIGIL = String.fromCharCode(160); // NBSP (non-breaking space)
        const { escapeText } = Modulo.templating.MTL.prototype;
        const { safe } = Modulo.templating.defaultOptions.filters;

        function syntaxHighlight(text) {
            text = escapeText(text);
            //text = text.replace(/&quot;.*?&quot;/g, '<span class="syn-string">$&</span>');
            //text = text.replace(/&gt;.*?&lt;/g, '<span class="syn-tag">$&</span>');
            text = text.replace(/\*.*?\*/g, '<span class="syn-bold">$&</span>');
            text = text.replace(/_.*?_/g, '<span class="syn-italic">$&</span>');
            text = text.replace(/^#+.*?$/gm, '<span class="syn-header">$&</span>');
            text = text.replace(/^\s*[+*-] /gm, '<span class="syn-ul">$&</span>');
            text = text.replace(/^\s*\d+[\.:]? /gm, '<span class="syn-ol">$&</span>');
            text = text.replace(/^---+$/gm, '<span class="syn-hr">$&</span>');
            text = text.replace(/`.*?`/g, '<span class="syn-code">$&</span>');
            text = text.replace(/\!?\[.*?\]\(.*?\)/g, '<span class="syn-link">$&</span>');
            return safe(text);
        }

        function mergeStrings(baseText, overlayText) {
            let baseIndex = 0;
            let overlayIndex = 0;
            let results = '';
            while (baseIndex < baseText.length || overlayIndex < overlayText.length) {
                const overlayChar = overlayText[overlayIndex];
                const baseChar = baseText[baseIndex];
                if (baseChar === SIGIL || baseChar === overlayChar) {
                    results += (overlayChar && overlayChar !== SIGIL) ? overlayChar : ''; // Ensure str
                    overlayIndex++;
                } else { // We are dealing with an insertion in the base:
                    results += baseChar ? baseChar : ''; // Ensure str
                }
                baseIndex++; // Always progress through base
            }
            return results;
        }

        function isCharacterKeyPress(ev) {
            if (typeof ev.which == "number" && ev.which > 0) {
                return !ev.ctrlKey && !ev.metaKey && !ev.altKey && ev.which !== 8;
            }
            return false;
        }

        // TODO wrap cbs below in callback
        let globalDebounce = null;
        function keyDown(ev) {
            const key = ev.key;
            const textarea = ev.target;
            setStateAndRerender(textarea); // Ensure state is updated with val 

            // Always clear globalDebounce if it exists
            if (globalDebounce) {
                clearTimeout(globalDebounce);
            }

            if (!isCharacterKeyPress(ev)) { // If it's not "normal typing"
                globalDebounce = setTimeout(() => setStateAndRerender(textarea), 50);
                return;
            }

            // Person is typing, remove keydown for as fast as possible
            // interaction
            textarea.removeEventListener('keydown', keyDown);
            const originalValue = textarea.value;
            // Replace all non-space with sigils, and add sigil to reserve space at caret
            let value = originalValue;
            value = value.replace(/[^\r\n ]/g, SIGIL);
            //value = value.substr(0, state.selectionStart - 1) + SIGIL + value.substr(state.selectionStart - 1);
            textarea.value = value; // Set "blanked" version of textarea
            textarea.style.color = 'black'; // Ensure their text is visible
            textarea.setSelectionRange(state.selectionStart, state.selectionStart);

            globalDebounce = setTimeout(() => {
                state.selectionStart = textarea.selectionStart;
                textarea.value = mergeStrings(textarea.value, originalValue);
                textarea.setSelectionRange(state.selectionStart, state.selectionStart);
                setStateAndRerender(textarea);
                textarea.addEventListener('keydown', keyDown); // restore keydown
            }, 50);
        }

        function updateScroll() {
            const { textarea } = element;
            if (!textarea) {
                return;
            }
            console.log('updating scrolling!');
            const { scrollTop, clientWidth, clientHeight } = textarea;
            if (state.scrollTop !== scrollTop ||
                    state.width !== clientWidth ||
                    state.height !== clientHeight) {
                state.scrollTop = scrollTop;
                state.width = clientWidth;
                state.height = clientHeight;
                element.rerender();
            }
            //offsetWrapperDiv.style.top = '-' + textarea.scrollTop + 'px';
        }

        function setStateAndRerender(textarea) {
            state.selectionStart = textarea.selectionStart;
            if (state.value !== textarea.value) {
                state.value = textarea.value;
                state.editorShadowHtml = syntaxHighlight(textarea.value);
                element.value = state.value;
                element.rerender();
            }
        }

        function textMount({ el }){
            const value = (props.value || '').trim();
            const textarea = el;
            element.textarea = textarea;
            textarea.value = value;
            setStateAndRerender(textarea);
            textarea.addEventListener('keydown', keyDown);
            try {
                new ResizeObserver(updateScroll).observe(textarea)
            } catch {
                console.error('Could not listen to resize of textarea');
            }
        }
    </Script>

    <Style>
        .editor-wrapper {
            position: relative;
        }

        .syn-bold { font-weight: bold; }
        .syn-italic { font-style: italic; }
        .syn-header {
            font-weight: bold;
            background: black;
            color: white;
        }
        .syn-code {
            border-bottom: 1px dotted green;
            color: green;
        }
        .syn-link {
            text-decoration: underline;
            color: blue;
        }
        .syn-ol,
        .syn-ul,
        .syn-hr {
            color: green;
            font-weight: bold;
        }

        pre.editor-shadow,
        textarea {
            top: 0;
            left: 0;
            font-size: 16px;
            width: 100%;
            border: none;
            padding: 0;
            margin: 0;
            min-height:  200px;
            font-family: monospace;
            text-align: start;
            resize: none;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            box-sizing: border-box;
        }

        .editor-underlay-container {
            position: absolute;
            left: 0;
            overflow: hidden;
        }
        .editor-underlay-offset-wrapper {
            left: 0;
            position: absolute;
        }

        textarea {
            position: relative;
            background: none;
            /*color: rgba(0, 0, 0, 0.001);*/
            color: rgba(0, 0, 0, 0);
            caret-color: rgb(0, 0, 0);
        }
    </Style>
</Component>


