<!DOCTYPE HTML>
<head>
</head><body>


<mws-section modulo-innerhtml="FAQ">
        <a class="secanchor" title="Click to focus on this section." id="" name="" href="#">#</a>
        <h2>FAQ</h2>
    </mws-section>

<h3><span alt="Question mark">?</span></h3>

<p>This FAQ, like every FAQ, is an imaginary conversation between the creator
(myself) of Modulo and imaginary people who apparently are invested in Modulo
enough to ask probing questions about it. That said, if you are a non-imaginary
person (I should hope so!) with questions about Modulo, they are welcome even
more: Contact via email, submit a pull request to this page, or add an issue to
the project on GitHub.</p>

<p>By reading this FAQ, you will get a better understanding of the motivation
of building Modulo and it's design philosophy.</p>

<hr>

<p><strong>Q: Why yet another JavaScript framework?</strong></p>
<p>A: To me, the very idea of writing YET ANOTHER JavaScript framework
is vomit inducing.<br>And yet here I am.</p>

<p>While working at Kickstart Coding, developing our Django-based
LMS, nothing quite fit the bill for a very simple JS framework to
sprinkle in some extra interactive features to an otherwise very
straight-forward multi-page web app. The current solution was a
mess of Vue and scattered vanilla JavaScript (okay, and a few old
jQuery plugins, that we'll totally get rid of ASAP totally), with
the build-step and mounting code for the Vue code getting almost as
complicated as the little it was even doing.</p>
<p>We didn't have the developer bandwidth needed for a SPA, and the
poor state of JS code was slowing down building features, not to
mention the brittle mounting process was hard to test.  If only I
could just <em>go in there and do some JS</em> without any more
fuss... but also develop using hot-reloading and a bundle in the
end. So, I gave up, gave in, and became the problem. I wrote yet
another JavaScript component framework.</p>

<hr>
<p><strong>Q: Any future plans?</strong></p>
<p>A: Yes, plenty! The goal of Modulo.js itself is to stabilize the API, polish
and bug-fix, and then not really change much or grow much after that (keep it
short and sweet). In addition to that, there is another project that is still
"experimental", and that is called <a href="/docs/mdu.html">MDU: Modulo
Developer Utilities</a>. This
project has two parts: <code>modulocli</code> and <code>mdulib</code>.

<br>
The modulocli tool is useful for both static-site generation (e.g. this site!),
and for "JAM stack" live sites. It's also useful as a companion tool for modulo
development, allows for the running of running test suites and testing of configurations.
<br>
However, it's still being documented, and the code quality requires
refactoring, so it still needs work before it's released externally. This modulocli
similar note, I have plans for a JAMstack-style SSG + server-side combo, with
live-refresh inspired by Phoenix LiveView. Finally, the goal of
<code>mdulib</code> will be to provide a standard library of useful reusable
Modulo components, CParts, and middleware, written in idiomatic Modulo
code.</p>

<hr>
<p><strong>Q: Why do you care so much about short source code
files? Don't you want a framework that does more?</strong></p>

<p>A: In my opinion, the most important feature about a framework
like this is documentation and structure, not functionality.
Specifically, my coding philosophy is that good frameworks should
have aim first and foremost to have a high "documentation to code"
ratio. This is because a framework is much more than simply a set
of libraries to import. Choosing a framework represents buy-in to
file and directory structures, recipes, best practices, code
patterns, and so on. I don't want to have to dig through
<em>other</em> people's code to figure out how to solve <em>my</em>
problems. Instead, a good framework should come "batteries
included" with documentation that clearly indicates how to solve
common problems.</p>

<p>Thus, to pump up our "doc/code" ratio, the easiest thing is to keep the
denominator as low as possible.  This is especially true for a new,
solo-developed framework project such as this one.  Similarly, I think that
frameworks should seek to be as simple and elegant as possible, especially in
this case, when the framework is a layer on top of existing web standards (the
web component standard). In this case, adding anything more would constitute
over-engineering.</p>

<hr>
<p><strong>Q: Can't you have both, however? Maybe not as a solo project, but
can't you have a big, extensive framework with big and extensive
documentation?</strong></p>

<p>Sure, it's possible, and for many situations a better choice, so you could
always use such a framework as well.  Modulo plays well with others! However,
Modulo takes a different approach.  See <a href="#philosophy">the design
philosophy "thought experiment"</a> below for for further and more thorough
discussion of Modulo's approach and it's motivation.</p>

<hr>
<p><strong>Q: 80 char line limit? 4 space indentation? Imperative
coding? What is this, Java code from the 90's?</strong></p>

<p>A: Another motivating factor for developing Modulo was how much I
appreciates libraries such as Django that maintain high quality docs and code,
and have an easy-to-follow codebase that you can always go to to understand
exact ordering or behavior of certain operations or steps. This is contrasted
with other libraries which seem to be designed first and foremost to go fast
and pass tests, but not for thorough documentation, or self-documenting code.
This is not a slight on any particular library, nor is it a claim that I write
better code‚Äîin fact, outside of Modulo.js itself, all the tooling code in
this repo is a mess!  However, for Modulo.js itself, I invested most of the
development time in refactoring it over and over (and over and over), until the
code and logical flow was as simple as possible. My goal is to make the code
readable and be a good example for novice coders. I want engineers of all skill
levels to be able to understand <em>why</em> the framework behaves the way it
does by simply reading the code that powers certain features.</p>

<p>That's where the coding standard comes in. Shorter line length and "more
intense" indentation requirements naturally causes simpler, less convoluted
code, causing desirable side-effects such as lower cyclomatic complexity in
functions. It might not be "pleasant" to write under these conditions, but code
is written once and read 1000 times. Modulo code was written to be easily read,
not easily written.</p>



<hr>
<p><strong>Q: Why call it Modulo?</strong></p>
<p>A: From Wikipeda: ‚ÄúIn mathematics, the term modulo is often used to
assert that two distinct mathematical objects can be regarded as equivalent if
their difference is accounted for by an additional factor.‚Äù Basically,
it's math jargon to say two things are equivalent in a given condition or
context.</p>

<p>So, maybe the goal of Modulo is provide that context, making a natural way
to integrate the new and the old! Or maybe it sounded cool. Maybe that!</p>

<hr>
<p><strong>Q: Isn't <em>Modulo</em> already a thing in
JavaScript?</strong>
</p><p>Ironically, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder">JavaScript does not have a modulo operator</a>!
Instead, it uses the percent sign as a <em>remainder operator</em>,
which behaves similarly for some numbers, but differs for negative
numbers. So, while Modulo.js is not the first thing to be called
<abbr title="At the time of picking the name, there were a couple
similarly named projects, though none seem to be in active use or
development for years.">"Modulo" in JS</abbr> it <em>is not</em>
named after the <code>%</code> operator in JavaScript, making both the logo and
the name a bit of a pedantic and tongue-in-cheek jab at our favorite (but
sometimes deficient) computer language.</p>


<hr>

<mws-section name="philosophy" modulo-innerhtml="Framework design philosophy">
        <a class="secanchor" title="Click to focus on this section." id="philosophy" name="philosophy" href="#philosophy">#</a>
        <h2>Framework design philosophy</h2>
    </mws-section>

<p>In this section, I'll give some of my design philosophy and opinions on what
makes a good framework. I don't think my opinions are particularly unusual or
novel, but I thought I'd lay them out here nonetheless.</p>

<p>Let's do a thought experiment. Imagine the most minimalist JS component
framework possible. Let's call it "Fish" (probably already a thing, but bare
with me), by Tux the Penguin (because hey, why not?). Here is the complete code
for the "Fish" framework:</p>

<mws-demo text="
<script>
// Fish Framework - (C) 2091 - Tux the Penguin
function Fish(el, key, value) {
    el.state = el.state || JSON.parse(el.getAttribute(&quot;x-state&quot;) || &quot;{}&quot;)
    el.state[key] = value;
    el.innerHTML = el.innerHTML.replace(/\$\{([^\)]+)?\}/g, (a, b) => el.state[b]);
}
</script>
" modulo-innerhtml=""><div class="demo-wrapper
        
           demo-wrapper__clipboard  
        
        demo-wrapper__notabs     
    ">
    

    <div class="editor-toolbar">
        <p style="font-size: 11px; width: 120px; margin-right: 10px; text-align: right;
                     display: none; ">
            <em>Note: This is meant for exploring features. Your work will not be saved.</em>
        </p>

        
            <button class="m-Btn m-Btn--sm m-Btn--faded" title="Copy this code" @click:="script.doCopy">
                Copy <span alt="Clipboard">üìã</span>
            </button>
        

        

    </div>

    <div class="side-by-side-panes">
        <div class="editor-wrapper">
            <div modulo-ignore="">
            </div>
        </div>

        

    </div>
</div>

</mws-demo>

<p>Now, Tux could just publish this by itself, and no one would ever want to
use it, since it it's just several lines of useless, undocumented code. People
copy &amp; paste far more code from Stack Overflow just for simple tasks!</p>

<p>However, now imagine Tux wrote documentation for it. Imagine Tux wrote a
massive recipe book of hundreds of examples, ranging from API usage to common
UI tasks.  For an example, skim (no need to actually thoroughly read) the
following "excerpt" of the imaginary "Fish" documentation:</p>

<mws-demo text="
<!-- Fish Framework - Documentation -->

<!-- BEGINNER EXAMPLE: BUTTON -->
<!-- Look how easy it is to make a button that counts: -->
<button
        onClick='Fish(this, &quot;count&quot;, this.state.count++)'
        x-state='{&quot;count&quot;: 3}'>
    <p>I ate {count} delicious herrings</p>
</button>

<!-- Okay, lets break it down:
        - By using the x-state directive, the core directive of Fish (see
          Chapter 2 on directives and how to create your own), we can set the
          initial state of an element.
        - What is state? An object that you can mutate to affect how your
          elements are displayed. Use it to store data from the DB, or
          elsewhere.
        - ... snip ...
-->

<!-- ADVANCED EXAMPLE: API -->
<!-- Lets see another example of state, this time with API: -->
<div x-state='{&quot;search&quot;: &quot;&quot;}'>
    <p>Information about account found: Their name is {name}</p>
    <input onChange='Fish(this.parentNode, &quot;search&quot;, this.value)'
        placholder=&quot;Type in a GitHub username...&quot;
    />
    <button onClick='
        fetch(`https://api.github.com/users/${this.parentNode.state.search}`)
            .then(response => response.json())
            .then(({name}) => Fish(this.parentNode, &quot;name&quot;, name))
        '>Search GitHub</button>
</div>

<!-- Okay, lets break it down:
        - In this example, you can see how ........... (- snip -) -->



<!-- UI TOOLKIT EXAMPLE: ACCORDIAN TOGGLE -->
<!-- Or, look how you can make toggle accordians elements just by using .... -->
<nav x-state='{}'>
    <li onClick='Fish(this.parentNode, &quot;info_class&quot;, &quot;visible&quot;)'>
        Show Info
    </li>
    <li onClick='Fish(this.parentNode, &quot;contact_class&quot;, &quot;visible&quot;)'>
        Show Contact
    </li>
    <li onClick='Fish(this.parentNode, &quot;blog_class&quot;, &quot;visible&quot;)'>
        Show Blog
    </li>
    <div class=&quot;{info_active}&quot;>Hi, this is info about my website...</div>
    <div class=&quot;{contact_class}&quot;>I live in Antarctica and write free software...</div>
    <div class=&quot;{blog_class}&quot;>Thoughts on fish: Why fish is actually...</div>
</nav>
" modulo-innerhtml=""><div class="demo-wrapper
        
           demo-wrapper__clipboard  
        
        demo-wrapper__notabs     
    ">
    

    <div class="editor-toolbar">
        <p style="font-size: 11px; width: 120px; margin-right: 10px; text-align: right;
                     display: none; ">
            <em>Note: This is meant for exploring features. Your work will not be saved.</em>
        </p>

        
            <button class="m-Btn m-Btn--sm m-Btn--faded" title="Copy this code" @click:="script.doCopy">
                Copy <span alt="Clipboard">üìã</span>
            </button>
        

        

    </div>

    <div class="side-by-side-panes">
        <div class="editor-wrapper">
            <div modulo-ignore="">
            </div>
        </div>

        

    </div>
</div>

</mws-demo>

<p>Now this is looking more and more like a complete framework! The missing
ingredient was documentation and examples. In fact, that was even more
important than the original code: The original code could be anything, just
setting up a stack, checking up some attributes, whatever, but without the
patterns  of usage around the original code it is meaningless nonsense.</p>

<p>In other words, when people think of a framework, they don't think of how
it's coded, they think what they can do with it. Thus, a framework can be
better thought of as a bundle of best practices and workflow, or a recipe book.
The "code" of the framework is immaterial, as long as the documented examples
work. In this case, the code was only a few lines long, yet the examples showed
that it could be used for a myriad of tasks.  In fact, these sorts of snippets
in the documentation can be thought of as being as much part of the framework
as anything else: That is how "best practices" and "common patterns" are
established.</p>

<p>In my view, non-opinionated frameworks are incomplete to the extent they
don't have opinions. That's not to say they are bad or useless, "unopinionated"
has it's time and place, but it's just to acknowledge that they are BYO ("bring
your own") for anything that the documentation doesn't explicitly establish
patterns of usage.  Just look at the dozens of ways that Redux is implemented
in the industry, for an example. Just saying that you use "Redux" tells little
about the code structure or practices, or the myriad of middleware that is
typically incorporated to handle various common use-patterns. Redux Toolkit
projects can look entirely different than other Redux projects! Once you "bring
your own" patterns to fill in these gaps, only then the framework is "truly
complete" (using the nomenclature I'm using in this document, at least). One
Redux setup might be so different than another due to patterns of usage, that
the lines defining them are a bit fuzzier, and they might as well be a
different framework.</p>

<p>With any project, very quickly the "userland" (e.g. developer's)
code eclipses the framework code in size and performance impact, which means
these best practices and pattern recipes can have a much bigger impact on the
resulting product than internal implementations. If the documentation shows
many slow performing examples, or if it doesn't suggest anything at all and
developers tend to go for slow implementations, I think it's perfectly fair to
say that the framework is "slow", regardless of the internal operations. (An
adjective that probably applies to Modulo as well!)</p>


<p>Modulo's goal is short code and long docs. It's basically "Fish", but
multiplied times 250. It's as though Tux continued hacking away, bringing it
from 5 lines to about 1000 lines, and then kept on hacking away at docs,
examples, and use-patterns, keeping them still proportionally much longer.</p>

<p>Coincidentally, this is actually somewhat how various parts of Modulo
originally were developed.  Modulo itself had an earlier incarnation called
MoEdCo (Modular Editor Components), which was a Web Components framework in
less than 500 lines for Electron.js. That, in turn, evolved out of a demo that
I live coded for a class I was teaching on React JavaScript back in 2017. The
in-class demo was a "React-like" in just a few dozen lines of code, to explain
the core philosophy and patterns used by React without the extra baggage of the
new syntax and complicated build environment. Similarly, the Modulo Template
Language evolved out of <a href="https://www.npmjs.com/package/tinytiny">TinyTiny</a>, which was an
expanded version of an even shorter "codegolf" challenge that I had done for
fun (now about a decade ago).</p>

<hr>

<p>Summary: A framework isn't just code, it's an entire workflow and way of
doing things. The code is important, but less important than the other
aspects.</p>

<p>Also, for clarity's sake: The "Fish" code above is untested, incomplete, and
almost certainly has deal-breaking bugs, but could work in principle with a
tweak or two and the right context. This doesn't matter either way for our
purposes.  Also, I'm very far from the first person to approach framework
development this way ‚Äî in fact, the increasingly popular Alpine.js
follows a similar principle! It also happens to resemble my silly "Fish"
example, but is actually real, so if you want an actually useful version of
this, <a href="https://alpinejs.dev/">check it out</a>.</p>





<script src="/js/codemirror_5.63.0/codemirror_bundled.js"></script><script src="/js/modulo-build-121.11-1rl6anl.js"></script></body>