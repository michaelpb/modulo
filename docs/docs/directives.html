<script src="/m.js"></script>
<x-Page
    docbarselected="directives.html"
    pagetitle="Templating Reference"
    navbar="docs">

<h1>Lifecycle & Directives</h1>


<mws-Section name="lifecycle">Lifecycle</mws-Section>

<p>Every Modulo Component goes through a certain "lifecycle". Here's an
analogy: If CParts are the stage-hands and actors who put on a play, then the
"lifecycle" is the pre-described arrangement of each "act", intermission, and
so on, such that every CPart stage-hand "jumps in" at the right moment to do
it's job and set up for the next act.</p>

<h3>Modulo lifecycle phases</h3>

<p>Modulo lifecycle phases can be categorized into a few groups. One way to
think these phases is that typically, the "output" of a previous lifecycle
phase in a group is the "input" of the next phase. As an example,
<code>load</code> generates a flat, serializable structure that
<code>factory</code> uses to instantiate more complicated JavaScript instances.
Similarly, <code>prepare</code> figures out the template variables,
<code>render</code> causes the template to actually perform the render based on
the variables in the previous phase, and <code>update</code> updates the HTML
of the element based on the rendered output of the previous phase.</p>


<h4>Group 1: Component Definition</h4>

<p>These phases happen <em>once per component definition</em>. These will
happen even if the component is never used or instantiated anywhere, but only
defined and loaded. They are intended for setting up the component "Factory"
(blueprint for component instances).</p>

<ul>
    <li><code>load</code> - The stage of parsing a code file. This is for
    static analysis and similar pre-processing. Note that if Modulo components
    are cached, or if they are ever pre-compiled into a single JS file, this
    <code>load</code> phase happens BEFORE saving, and thus gets "baked-in".
    This means that the results of a <code>load</code> phase must be
    "serializable", such as in a JSON format.</li>

    <li><code>factory</code> - Any one-time, global set-up for a component
    (e.g. compiling the template). This happens after the <code>load</code>,
    but before the component is used.  Unlike the <code>load</code> phase,
    <code>factory</code> happens after the page loads, and thus does not need
    to generate serializable results.</li>
</ul>

<p><strong>Note:</strong> "Group 1" is only accessible to <em>CPart</em>
developers, and <em>not</em> accessible to component developers using script
tags.</p>

<h4>Group 2: Component Instantiation</h4>
<p>Currently, only one lifecycle phase is triggered when a component is mounted
on the page.</p>
<ul>
    <li><code>initialized</code> - happens once per instance, every time a
    component is instantiated or mounted (i.e. used) on a page. Useful for
    fetching or setting up initial data on a component, as all the component
    will be fully ready for use at this point.</li>
</ul>


<h4>Group 3: Component Rendering</h4>
<p>All of 4 these lifecycle phases trigger in the following sequence every time
a component renders.  This including the first time, every manual rerender
(e.g. invoking <code>element.rerender()</code>), and ever automatic rerender
(e.g. after events or state manipulation). These will phases even trigger if
you don't have a <em>Template</em> CPart defined, although without a
<em>Template</em> there will be nothing to render.</p>

<ul>
    <li><code>prepare</code> - Gather data needed before rendering (e.g. gather
    variables for template)</li>
    <li><code>render</code> - Use the Template to render HTML code</li>
    <li><code>reconcile</code> - Compares the new rendered HTML to the DOM, and
    generates a "patch-set" or array of operations necessary to reconcile the
    DOM to the new HTML</li>
    <li><code>update</code> - Applies the "patches" generated in the previous
    step, actually modifying the DOM and invoking directives</li>
</ul>


<h4>Group 4: Directives</h4>

<p>Directives can also have lifecycle phases. More information on them is <a
href="#directives">covered below</a>. For now, we'll look at 2 lifecycle phases
that are introduced whenever an event occurs. That is, these phases will be
available whenever you attach an event, e.g. <code>@click</code>.</p>

<ul>
    <li><code>event</code> - Triggers when an event is about to happen.</li>
    <li><code>eventCleanup</code> - Triggers after an event happened. A common
    pattern is to use this and the previous to figure out what has "changed"
    due to the event, and respond accordingly.</li>
</ul>



<h3>Hooking into a lifecycle phase</h3>

<p>The purpose of <em>lifecycle phases</em> is the <em>lifecycle methods</em>
or functions that "hook into" each phase and run during them.</p>

<p>You can get the name for a <em>lifecycle method</em> by simply suffixing the
name of the phase with the word <code>Callback</code>. For example,
<code>prepare</code> thus becomes <code>function prepareCallback() {...</code>.
Every CPart has the ability to hook into lifecycle methods by defining a method
with an expected name. This is useful for CPart developers to implement the
actual behavior and functionality of a CPart. In fact, most of CPart code is
just hooking into these different methods!</p>

<p>The <em>Script</em> CPart also exposes this interface to component
developers. This is so that you can write custom code in each component to
execute during any one of the phases. Note that you cannot hook into Group 1
phases this way, since those need to happen before your script tag is even
ready (in fact, it's the <code>factoryCallback</code> of <em>Script</em> that
hooks your custom methods into the component lifecycle.</p>

<p>Directives also have callback functions, <a href="#directives">covered
in a later section</a>.</p>

<p><strong>Try it out below:</strong></p>

<mws-Demo demotype="minipreview"
text='
<template>
Hello <strong>Modulo</strong> World!
Open your browser dev console to see messages...
<button @click:=script.gotClicked>Click me to generate an event</button>
</template>

<script>
    function initializedCallback() {
        console.log("initalizedCallback: Got mounted");
    }

    function prepareCallback() {
        console.log("prepareCallback: Starting to render");
    }

    function renderCallback() {
        console.log("renderCallback: Rendering!");
    }

    function updateCallback() {
        console.log("updateCallback: Reconciling the DOM!");
    }

    function updatedCallback() {
        console.log("updatedCallback: Done with render");
    }

    function eventCallback() {
        console.log("eventCallback: An event happened");
    }

    function eventCleanupCallback() {
        console.log("eventCleanupCallback: After the event");
    }

    function gotClicked() {
        console.log("(the button got clicked)");
    }
</script>
'></mws-Demo>


</section>



<mws-Section name="renderobj">renderObj</mws-Section>

<blockquote>
<p><strong>renderObj is like "req" </strong> -
<code>renderObj</code> is comparable to the "request" or "response" objects
in many backend MVC frameworks, such as in Express.js or Django. In these,
middleware works behind the scenes to modify or construct the "request" object.
They prepare it for the controller functions that accept it as an argument, by
attaching data and injecting dependencies.  For a concrete example, enabling
Express's JSON parsing middleware adds the <code>req.json</code> attribute to
request objects, for parsing of JSON data.</p>
<p>This is what inspired the
<code>renderObj</code>: It's a plain object that gets passed along throughout
<em>all</em> of the lifecycle phases (including the factory callback!). All the
CParts, much like middleware, work together to construct it and make it ready
for component developers.</p>
</blockquote>

<p>So far in this document, we covered how lifecycle methods are central to
CParts, and that CParts are central to Modulo components in general.
Now, we will learn how <code>renderObj</code> is central to lifecycle methods.
It's how lifecycle methods pass data and communicate, as a component passes
through the different phases.</p>


<h3>renderObj and lifecycle</h3>

<p>The renderObj goes through 3 phases. The first is during set-up, the second
during component factory initialization, and the third happens every time a
component rerenders.</p>

<ol>
    <li><code>loadObj</code> - This is the version created during the
    <code>load</code> phase, and is typically just the text and attributes of
    the component definition with any pre-processing done. Unlike the other
    objects, <code>loadObj</code> <em>can only</em> contain plain or
    JSON-friendly data types.</li>

    <li><code>baseRenderObj</code> - The <code>loadObj</code> is copied to the
    <code>baseRenderObj</code>, which is the result of the <code>factory</code>
    phase. This might have more dependencies injected, e.g. the template CPart
    at this point will have compiled the template code a JS function.</li>

    <li><code>renderObj</code> - This is the one that component developers are
    more likely to encounter. During first render, and every time a
    <code>.rerender()</code> method is called, <code>renderObj</code> is
    duplicated from the <code>baseRenderObj</code>, and then gets passed around
    through the <code>prepare</code>, <code>render</code>, <code>update</code>,
    and <code>updated</code> phases.</li>
</ol>




<p>Typically, unless developing new CParts, you will have little need to
directly interact with the <code>renderObj</code>. You already implicitly use
it in several cases. For example,
whenever you access variables in the <em>Script</em> CPart, the
<code>state</code> variable is in fact shorthand for
<code>element.renderObj.state</code>, or whenever you access <a
href="http://icheb.local:8080/docs/templating.html#variables">variables in the
template</a> <em>CPart</em> (e.g., <code>props.text</code> is
shorthand for <code>element.renderObj.props.text</code>).
So, if you are a component developer and not a CPart developer, and you find
yourself thinking that it doesn't make a lot of sense why you'd need to access
or modify the <code>renderObj</code> explicitly... You probably don't!</p>

<p>Nevertheless, use the following example to examine the output of the
following example to see what information is available or modified at each
step:</p>


<mws-Demo demotype="minipreview"
text='
<template>
<label>
<input [state.bind] name="enabled" type="checkbox" />
Show messages in console</label>
</template>

<state
    enabled:=false
></state>

<script>
    function _logInfo(message, renderObj) {
        // Little helper function to do messages in console
        if (state.enabled) {
            const formattedOutput = JSON.stringify(renderObj, null, 2);
            console.log(message, formattedOutput);
        }
    }

    function prepareCallback(renderObj) {
        _logInfo("prepareCallback:",  renderObj);
    }

    function renderCallback(renderObj) {
        _logInfo("renderCallback:", renderObj);
    }

    function updateCallback(renderObj) {
        _logInfo("updateCallback:", renderObj);
    }

    function updatedCallback(renderObj) {
        _logInfo("updatedCallback:", renderObj);
    }
</script>
'></mws-Demo>


<mws-Section name="directives">Directives</mws-Section>

<blockquote><p><strong>Directives are like "refs"</strong> - Directives have
the same uses as Refs in <a
href="https://reactjs.org/docs/refs-and-the-dom.html"
target="_blank">React</a>: &ldquo;Managing focus, text selection, or media
playback, triggering imperative animations, or integrating with third-party DOM
libraries.&rdquo;</p></blockquote>

<p><em>Directives</em> are one of the core features of Modulo. It allows for
callbacks to be triggered when a particular DOM element is "mounted" or first
appears in the DOM. It allows for your custom code to access references to DOM
nodes created after rendering.</p>

<p>Every directive has a name. Every directive is specified as an attribute on
the DOM element that you wish to gain access to, by enclosing the name in
square brackets. For example, the <em>State</em> CPart has the directive named
<code>bind</code>, making the full attribute be <code>[state.bind]</code>. Some
directives have shortcut names. For example, <code>[component.event]</code> can
be shortened to only a single at-sign, <code>@</code>.</p>

<p>Directives also have callback functions. Just like lifecycle callbacks, a
directive callback name is created by suffixing a string to the end of the name
of the directive. Unlike lifecycle callback functions, directive callback
functions end with <code>Mount</code> and <code>Unmount</code>.</p>

<h3>Built-in directives vs custom directives</h3>

<p>Modulo ships with a total of 4 built-in directives, defined by the built-in
<em>CParts</em> (1 from <em>State</em> and 3 from <em>Component</em>).
Typically, the built-in directives are all you need. However, just like with
lifecycle functions, the <em>Script</em> CPart also exposes the directive
interface to component developers. This is so that you can create custom
directives in a component to access the DOM after rendering.</p>

<p>A quick word of caution on custom directives: If you find yourself using
custom directives to do vanilla JS DOM manipulation often, you are probably
doing something wrong! They are meant as an "emergency escape hatch" to gain
access to the DOM underneath, and typically you only use them to integrate with
other libraries. The most common usage is mixing in older jQuery-style
libraries that require a reference to a DOM element. In general, it's when you
run into the limits of what Modulo is capable of doing.</p>

<p><strong>Example custom directives:</strong></p>

<mws-Demo demotype="minipreview"
text='
<template>
{# [script.myinput] is a custom directive, defined below #}
<input [script.myinput] />

{# [component.event] is a built-in directive (shortcut is @) #}
<button [component.event]click:=script.showInfo>
    Click me
</button>
</template>

<script>
    function myinputMount(mountOptions) {
        element.inputRef = mountOptions.el;
        // Try uncommenting the following to see data:
        //console.log("myinputMount:", mountOptions);
    }
    function showInfo(el) {
        alert("Focusing on:" + String(element.inputRef));
        element.inputRef.focus();
    }
</script>
'></mws-Demo>

<!--<mws-Section name="builtin">Built-in directives</mws-Section>-->

<h3>Built-in directives</h3>

<p>Modulo ships with a total of 4 built-in directives, defined by the built-in
<em>CParts</em> (1 from <em>State</em> and 3 from <em>Component</em>).</p>

<ul>
    <li><code>[state.bind]</code> - Two-way binding with <em>State</em>
    data, with the key determined by the <code>name=</code> property of
    whatever it is attached to.</li>

    <li><code>[component.children]</code> - Reattach the original child
    elements that this component had when it was first mounted to a new DOM
    element. (For React users, this is similar to doing
    <code>{this.props.children}</code>.)</li>

    <li><code>[component.event]</code> (<em>shortcut:</em> <code>@</code>) -
    Attach event listeners to DOM elements, and remove them when the DOM
    elements are removed. (For jQuery users, this is used for similar purposes
    as "live" (delegated) events, but is faster.)</li>

    <li><code>[component.dataProp]</code> (<em>shortcut:</em> <code>:</code>) -
    Attach data to a DOM element's `.dataProp` object, which can be used to
    directly pass <code>renderObj</code> values as <em>Props</em> or
    events</li>
</ul>

<h3>Directives vs templates</h3>

<p>Important directive facts: Directives are discovered during the
<code>update</code> lifecycle phase when DOM reconciliation is occurring, and
invoked during the <code>updated</code> phase. Note that they are independent
of the <em>Template</em> CPart: You can have a component that has no
<em>Template</em> but still may employ directives, e.g. if it generates HTML
contents some other way.</p>

<p>Not sure which to use? Short answer: Templates! Long answer: Directives deal
with direct DOM references, and thus are almost always messier to use. The <a
href="/docs/templating.html">design philosophy of Modulo's templating
system</a> is to generate a string of HTML code as a purposeful limitation
during the <code>render</code> phase, and thus prevents this messiness with a
stricter structure.</p>


<div class="InfoBox">
    <h2>Directives and template variables</h2>

    <p>Never attempt to mix <em>Template</em> CPart variables with directives.
    Directives cannot access template variables, since directives are only are
    applied after the template is fully rendered and all template variables are
    already forgotten. As an example, consider the following code:</p>

<mws-Demo
text='
<template>
    {% for athlete in state.team %}
        {# (HTML Attributes) #}
        {# Broken, will not work: #}
        <a href:=athlete.url>{{ athlete.name }}</a>

        {# Correct, will work: #}
        <a href="{{ athlete.url }}">{{ athlete.name }}</a>

        {# (Events) #}
        {# Also broken, will not work: #}
        <button @click:=athlete.myClickCallback>
            {{ athlete.name }}</button>

        {# Correct, will work: #}
        <button @click:=script.selectOne payload="{{ athlete.id }}">
            {{ athlete.name }}</button>
    {% endfor %}
</template>
'></mws-Demo>

<blockquote>
    <p><strong>Why "payload"?</strong> Why does Modulo take this approach, vs
    something like React, that allows direct attachment of anonymous JavaScript
    functions? As any React developer knows by now, there are a lot of
    "footguns" (common mistakes) with attaching events like this, specifically
    because complexities with "this" context, anonymous functions, and bound
    functions with arguments can make introspection (e.g. interactive
    debugging) hard.</p>

    <p>The Modulo approach is always "DOM determines behavior".  Just by using
    "Inspect" in your browser's Developer Tools, you can examine or even modify
    the "payload" attribute while debugging event behavior. In other words,
    Modulo <em>tends to treat the DOM as the "source of truth"</em>, and thus
    derives it's behavior from properties on DOM elements.</p>
</blockquote>

    <p>The first attempt (HTML Attributes) uses a directive (<code>[component.dataProp]</code>, in
    this case using the colon <code>:</code> shortcut), in an attempt to "directly"
    attach the URL to href. The second attempt correctly uses the template variable
    with double curly braces to embed it as an actual HTML property.  The first
    attempt will fail because it fails to take into account that the directives
    will happen <em>after</em> rendering the template. That is, the resulting HTML
    will literally resemble something like this:
    &ldquo;<code>&lt;a href:=athlete.url&gt;Steph Curry &lt;/a&gt;
    &lt;a href:=athlete.url&gt;Megan Rapinoe&lt;/a&gt;
    &lt;a href:=athlete.url&gt;Devante Adams&lt;/a&gt;</code>&rdquo;.

    <p>In other words, the "athlete" variable <em>is a temporary Template
    variable in the for loop</em> (that is to say, not a variable in the
    <em>renderObj</em>), and will only be used at the templating step, and
    forgotten immediately after. Since directives are only invoked once
    templating is fully completed, there is no way to resolve the variable from
    the for loop.</p>


    <p>What is the proper use of the <code>[component.dataProp]</code>
    directive, you might ask? The proper use is for direct assignment or
    attachment of values that are not strings or numbers <em>at the top level
    of the renderObj</em>. Basically, anything that can't be conveniently
    serialized into a string attribute. The common usage is passing down
    complex nested data types as <code>Props</code> (i.e. without having to
    clutter the DOM and waste memory with a massive JSON object serialized as
    an attribute), or for attaching callbacks from the renderObj.</p>

    <p>We see such correct usage in the second (Events) "correct" example: It
    references <code>script.selectAthlete</code> which is at the global level.
    We can tell that it's at the global renderObj level since it starts with
    <code>script.</code>, referencing the contribution to the renderObj that
    was provided by the Script CPart. The issue with this, however, is that we
    won't know <em>which</em> button was clicked, since it references one
    universal <code>selectAthlete</code> function.
    This is solved by attaching some sort of ID reference to the DOM element as
    a "payload" so that the callback function knows which athlete was selected.
    This is the correct approach: It uses the DOM as a "source of truth" and is
    predictable in behavior, with no "hidden" functions getting attached.</p>

</div>


<h3>Registering CPart directives with shortcuts</h3>

<p>If you are a CPart developer, you might want to register a shortcut along
with your CPart's directive. Note that this only applies to CPart developers:
Component developers should never create shortcuts for the script-tag based
custom directives used (which should be avoided to begin with).</p>


<p>See below for an example:</p>

<mws-Demo demotype="minipreview"
text='
<template>
    Game Shop: 31 moneys<br />
    Avg Movie Creeps: 10 moneys<br />
    <button @click:=script.toggle>
        {% if state.show %}
        Show controls (and trigger mount directive callbacks)
        {% else %}
        Hide controls (and trigger unmount callbacks)
        {% endif %}
    </button> <br />
    {% if state.show %}
        <button %%%buy="GMC">(text is replaced)</button>
        <button %%%sell="GMC"></button>
        <button %%%long="AMC"></button>
        <button %%%short="AMC"></button>
    {% endif %}
</template>

<state
    show:=false
></state>

<script>
    Modulo.directiveShortcuts.push([/^%%%/, "script.example"]);
    /*
    // Correct way below:
    function factoryCallback(partOptions, factory, loadObj)  {
        loadObj.component.directiveShortcuts.push([/^%%%/, "script.example"]);
    }
    */

    function exampleMount(info) {
        console.log("Mounting directive:", info);
        const {el, value, attrName, rawName} = info;
        el.textContent = `${attrName} ${value}`;
        el.onclick = () => alert(attrName + "ing " + value);
    }
    function exampleUnmount(info) {
        console.log("Unmounting directive:", info);
    }
    function toggle() {
        state.show = !state.show;
    }
</script>
'></mws-Demo>

<p><strong>Note:</strong> "Do as I say, not as I do": To keep the previous
example simple, we are demonstrating it's use within a script tag in a
component, but in general shortcuts are only intended for CPart directives, not
custom script tag directives.</p>


</x-Page>
