<script src="/m.js"></script>

<x-Page
    docbarselected="cparts.html"
    pagetitle="CParts"
    navbar="docs">

<h1>CParts</h1>


<blockquote>
<p><strong>Custom CParts?</strong> Here we describe core CParts used by
component developers, which are sufficient for most common use-cases.
However, if you are instead looking to extend this core functionality with
custom CParts written in JavaScript, refer to the <a href="/docs/api.html">API
&amp; Extension documentation</a>.</p>
</blockquote>

<p>The central concept to Modulo is that of <em>Component Parts</em>. Because
it is so central, saying <em>Component Parts</em> over and over gets tiresome,
so it's typically shortened to <em>CParts</em>. Every component definition
consists of configuring one or more CPart definitions. Modulo comes
"batteries-included" with about 8 CParts, which provide the core functionality
of building Modulo Components, and are documented here.</p>

<p>Conventionally, when defining components, CParts are listed in the following
order within a given <em>Component</em> definition:</p>

<ol>
    <li>Props</li>
    <li>Template</li>
    <li><em>(Any custom CParts)</em></li>
    <li>State <em>(and/or Store)</em></li>
    <li>Script</li>
    <li>Style</li>
</ol>

<p>The rationale for this ordering is to put Props and Template first since
they are often the first CParts that are important to read when trying to
understand or debug the behavior of a Component, while putting Style last as
it's typically the least important to read.</p>


<mws-Section name="props">Props</mws-Section>

<blockquote>
<p><strong>Read-only</strong> Props are read-only within a component, and only
be set by the parent component. If the values change, the component re-renders
with the new values. They are only supposed to be information being <em>passed
to</em> the component, which means they can't be changed internally.  For
internal, mutable data, use <a href="#state">State</a> instead.</p>
</blockquote>


<p>Props allow components to receive data. You can think of Props as being like
"function parameters": They allow you to pass down "arguments" (attributes) to
component which can then modify it's appearance, behavior, or content based on
the values of these parameters. For more discussion of Props, see
<a href="/docs/tutorial_part2.html#props">Tutorial Part 2</a>.</p>

<p>Props are set by the parent component (or HTML page).  For String values,
use plain attributes (e.g. <code>&lt;x-Btn design="round"&gt;</code>).  For any
non-String types, you can use <em>data props</em> set using a <code>:=</code>
directive syntax for (e.g.
<code>&lt;x-Chart data:='[1, 2, 3]'&gt;</code>).</p>



<h3>Definition</h3>

<p>Every "prop" within a <em>Props</em> CPart definition can be defined in one
of 4 ways:</p>

<ol>
    <li><strong>Any type, required</strong> - Specify the name of the prop in
    the CPart definition, but give it no value. This will be able to receive
    data in any type (e.g. String, and/or a JSON type or Function set with
    <code>:=</code> data prop syntax). By default, all props are required,
    meaning if this component is used without a required prop being set, it
    will throw an error and will not render.</li>

    <li><strong>Type-checked, required</strong> - Give the name of a <em>type
    validator</em> as a value when defining a Prop to enforce data of only
    certain types being accepted by a Component. There are a number of built-in
    <em>type validators</em> that you can use for common types:
    <code>String</code>, <code>Number</code>, <code>Boolean</code>,
    <code>Array</code>, <code>Object</code>, <code>Date</code>, and
    <code>Function</code>. You can also create your own validators: The
    <em>type validator</em> can be the name of any function that will return
    <code>undefined</code> if the given prop is of an incorrect type, or
    the value of the prop (with any necessary "casting" or conversion applied)
    if it's a valid Prop.  The Props CPart will then use these validators to
    provide more helpful error messages. If you want to support more than one
    type, allowing <em>any</em> of them, use comma separation (without
    spaces).</li>

    <li><strong>Any type, optional with default</strong> - To make an optional Prop, you
    must specify it's default value.  To specify a default value, repeat
    attribute with a <code>.default</code> suffix. If a default is specified,
    the component will no longer cause an error when it does not encounter a
    value, but instead use the default value.   If you don't expect to use the
    default value, but still want to make a prop optional nonetheless (e.g.
    perhaps  its usage is dependent on the value of another prop), consider
    setting the default value with <code>:=null</code>.</li>


    <li><strong>Type-checked, optional with default</strong> - Finally, by
    combining both type-checking with specifying default values, we can make
    Props that are both type-checked and optional.</li>
</ol>


<p>See below for an example of each of the 4 types of Props:</p>

<mws-Demo
text='
    <!-- 1. Any type, required -->
    <props
        design
        data
    ></props>

    <!-- 2. Type-checked, required -->
    <props
        design=String
        data=Array
    ></props>

    <!-- 3. Any type, optional with default -->
    <props
        design
        design.default="square"
        data
        data.default:=&apos;[1, 2, 3]&apos;
    ></props>

    <!-- 4. Type-checked, optional with default -->
    <props
        design=String
        design.default="square"
        data=Array
        data.default:=&apos;[1, 2, 3]&apos;
    ></props>
'></mws-Demo>



<h3>renderObj</h3>

<p>Props contributes it's received values to the renderObj. Examples:<p>

<ol>
    <li>Prop set like: <code>&lt;x-Btn design="round"&gt;</code> will be
    accessible on the renderObj like <code>renderObj.props.design</code>, and
    in the Script or Template CParts like <code>props.design</code>.</li>

    <li>Prop set like: <code>&lt;x-Chart data:='["a", "b"]'&gt;</code> will be
    accessible on the renderObj like <code>renderObj.props.data</code>, and
    in the Script or Template CParts like <code>props.data</code>.</li>
</ol>


<h3>Examples</h3>

<p>TODO: Need example here where you can control both "sides", both the prop
definition and use of the component.</p>


<mws-Section name="template">Template</mws-Section>

<p>The <em>Template</em> CPart allow components to render their HTML content
using a small domain-specific language, called the "templating engine". The
default engine is the <em>Modulo templating language</em> (aka "MTL"), although
that can be configured on a per-CPart basis.</p>

<p>Without a <em>Template</em> CPart (or equivalent custom code), the default
behavior of the <em>Component</em> CPart is to make no attempt to alter their
contents. However, most components require complicated HTML structures within
them. This is where Templates come into play: They generate the
<code>innerHTML</code> of a component.</p>

<p>Templates are not DOM-based, but instead render synchronously to a String
during the <code>render</code> <a
href="/docs/directives.html#lifecycle">lifecycle phase</a>, and setting that to
the <code>renderObj.component.innerHTML</code>. The <em>Component</em>  CPart
will take whatever is written there during the <code>updated</code> phase and
then "reconcile", modify it's contents to resemble the target innerHTML. (More
on this is in <a href="#component">the Component CPart documentation below</a>.)</p>


<p>Every time a Component renders, the Template will render using the
<em>renderObj</em> as a "template context", or, in other words, using the
various CPart's contributions to the <em>renderObj</em> as Template variables
that can be inserted into the HTML.  For a more discussion of Template, see
<a href="/docs/tutorial_part2.html#templating">Tutorial Part 2</a>.</p>



<mws-Section name="state">State</mws-Section>
<p>TODO</p>


<mws-Section name="state">Store</mws-Section>
<p>TODO</p>


<mws-Section name="script">Script</mws-Section>
<p>TODO</p>


<mws-Section name="style">Style</mws-Section>
<p>TODO</p>


<mws-Section name="component">Component</mws-Section>
<p>TODO</p>



<h3>attrs</h3>

<p>Components CParts use their attributes to set several configuration options.
They take the following attributes:</p>

<ul>
    <li><code>engine</code> - <em>default is <code>engine="ModRec"</code></em> -
    The Reconciler Engine selected. By default, ModRec, the built-in Modulo
    Reconciler engine, is enabled. If you want to experiment with other
    reconciliation engines, such as ones that might be faster or take into
    account unusual scenarios, set this equal to another property of
    <code>Modulo.reconcilers</code>.</li>

    <li><code>rerender</code> - <em>default is <code>rerender="event"</code></em>.
    Specify mode to change the render mode of this component. This allows you
    to isolate outside CSS from your component using "shadow", do one-time
    renders only with "vanish", or make your component replace the entire
    document with "vanish-into-document". A detailed discussion of valid
    options are below:
        <ul>
            <li><code>rerender="event"</code> - The default behavior, where the
            the component will rerender after ever event it handles (e.g. after
            every user interaction).</li>

            <li><code>rerender="manual"</code> - Set this to only rerender when
            this.rerender() is invoked. This is useful if there are many events
            that don't cause changes (e.g. mouse movement), but the extra
            rerenders, even if things aren't changing, impact performance. Note
            that if this is set, you will have to manually rerender, such as in
            a <em>Script</em> CPart.</li>
        </ul>
    </li>

    <li><code>mode</code> - <em>default is <code>mode="regular"</code></em>.
    Specify mode to change the render mode of this component. This allows you
    to isolate outside CSS from your component using "shadow", do one-time
    renders only with "vanish", or make your component replace the entire
    document with "vanish-into-document". A detailed discussion of valid
    options are below:
        <ul>
            <li><code>mode="regular"</code> - The default behavior, where the
            content generated by this the element will be attached to the
            regular DOM, as the element itself. This means that CSS stylesheets
            attached the normal way (e.g. with a "link" tag) will affect the
            contents of this component (however, <em>Style</em> CParts are
            still automatically scoped).</li>

            <li><code>mode="shadow"</code> - Use the so-called "shadow DOM" to
            render the content generated by this component. While the
            <em>shadow DOM</em> may sound like a sci-fi villain, it's a
            mechanism browsers provide for custom elements to isolate their
            contents from CSS selectors or other JavaScript libraries. This
            isolation means means that CSS stylesheets attached the normal way
            (e.g. with a "link" tag) <em>will not</em> affect the contents of
            this element.  Note that other than the isolation provided, the
            shadow mode should work exactly the same as regular. That said,
            <em>Style</em> CParts will still be automatically scoped to the
            component, but will use the shadowDOM feature to more strictly
            enforce that scoping, although theoretically this shouldn't change
            behavior.</li>

            <li><code>mode="vanish"</code> - This less used setting causes the
            component to "vanish" after rendering, or replace itself with it's
            children. Setting this will cause the component to remove itself
            after the first time it renders, effectively using the component as
            a simple template. This "one-time render" feature was written with
            SSG-style features in mind</li>


            <li><code>mode="vanish-into-document"</code> - This setting is
            useful in one situation: When you want to create a "page" level
            component that changes tags that belong in the document head, such
            as <code>&lt;title&gt;</code>. Like with <code>mode="vanish"</code>
            described above, setting this will cause the component to remove
            itself after the first time it renders. However, with
            vanish-into-document, it will instead replace the entire page.
            It will also attempt to correctly insert all tags that belong in
            the document head (meta, title, link, script to be specific),
            causing link and script tags alike (e.g.
            <code>&lt;script src=".."&gt;&lt;/script&gt;</code>) to load.
            Finally, the document will be wiped, and anything else it finds
            will be put directly into the document's body, for a clean DOM
            structure that removes itself entirely during this "one-time
            render".</li>
        </ul>
    </li>
</ul>

<mws-Section name="module">Module</mws-Section>
<p>TODO</p>


</x-Page>
