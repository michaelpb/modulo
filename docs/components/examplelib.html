<module>
    <script>
        // Splits up own source-code to get source for each example
        const mySrc = '/components/examplelib.html';
        const myText = Modulo.fetchQ.data[mySrc];
        const componentTexts = {};
        if (myText) {
            let name = '';
            let currentComponent = '';
            let inTestSuite = false;
            for (const line of myText.split('\n')) {
                const lower = line.toLowerCase();
                if (lower.startsWith('</component>')) {
                    componentTexts[name] = currentComponent;
                    currentComponent = '';
                    name = null;
                } else if (lower.startsWith('<component')) {
                    name = line.split(' name="')[1].split('"')[0];
                } else if (lower.startsWith('<testsuite')) {
                    inTestSuite = true;
                } else if (lower.includes('</testsuite>')) {
                    inTestSuite = false;
                } else if (name && !inTestSuite) {
                    currentComponent += line + '\n';
                }
            }
        }
        script.exports.componentTexts = componentTexts;
    </script>
</module>

<!--
/*} else if (sName === 'style') {
    console.log('this is content', data.content);
    const content = data.content.replace(/\*\/.*?\*\//ig, '');
    // To prefix the selectors, we loop through them,
    // with this RegExp that looks for { chars
    content.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/gi, (selector, data) => {
        console.log('selector', selector);
        console.log('data', data);
    });*/
-->

<component name="Hello">

<Template>
    <button @click:=script.countUp>Hello {{ state.num }}</button>
</Template>
<State
    num:=42
></State>
<Script>
    function countUp() {
        state.num++;
    }
</Script>

<testsuite
    src="./examplelib-tests/Hello-tests.html"
></testsuite>

</component>




<component name="Simple">

<Template>
    Components can use any number of <strong>CParts</strong>.
    Here we use only <em>Style</em> and <em>Template</em>.
</Template>

<Style>
    em { color: darkgreen; }
    * { text-decoration: underline; }
</Style>

<testsuite>
    <test name="Initially renders">
        <template>
            Components can use any number of <strong>CParts</strong>.
            Here we use only <em>Style</em> and <em>Template</em>.
        </template>
    </test>
</testsuite>

</component>




<component name="ToDo">
<Template>
<ol>
    {% for item in state.list %}
        <li>{{ item }}</li>
    {% endfor %}
    <li>
        <input [state.bind] name="text" />
        <button @click:=script.addItem>Add</button>
    </li>
</ol>
</Template>

<State
    list:='["Milk", "Bread", "Candy"]'
    text="Beer"
></State>

<Script>
    function addItem() {
        state.list.push(state.text); // add to list
        state.text = ""; // clear input
    }
</Script>

<testsuite
    src="./examplelib-tests/ToDo-tests.html"
></testsuite>

</component>

<!--list:=&#39;["Milk", "Bread", "Candy"]&#39;-->


<component name="JSON">
<!-- Use StaticData CPart to include JSON from an API or file -->
<Template>
    {% for post in staticdata %}
        <p><strong>{{ post.title }}</strong> - {{ post.body|truncate }}</p>
    {% endfor %}
</Template>
<StaticData
    src="https://jsonplaceholder.typicode.com/posts"
></StaticData>
</component>


<component name="StaticAPIUsage">
<!-- Use StaticData CPart to include JSON from an API or file -->
<Template>
    {{ staticdata.language }}:<br>
    <a href="{{ staticdata.html_url }}">{{ staticdata.name }}</a>
</Template>
<StaticData
    src="https://api.github.com/repos/michaelpb/modulo"
></StaticData>
</component>


<component name="API">
<Template>
<p>{{ state.name }} | {{ state.location }}</p>
<p>{{ state.bio }}</p>
<a href="https://github.com/{{ state.search }}/" target="_blank">
    {% if state.search %}github.com/{{ state.search }}/{% endif %}
</a>
<input [state.bind] name="search"
    placeholder="Type GitHub username" />
<button @click:=script.fetchGitHub>Get Info</button>
</Template>

<State
    search=""
    name=""
    location=""
    bio=""
></State>

<Script>
    function fetchGitHub() {
        fetch(`https://api.github.com/users/${state.search}`)
            .then(response => response.json())
            .then(githubCallback);
    }
    function githubCallback(apiData) {
        state.name = apiData.name;
        state.location = apiData.location;
        state.bio = apiData.bio;
        element.rerender();
    }
</Script>

<testsuite
    src="./examplelib-tests/API-tests.html"
></testsuite>

</component>





<component name="SearchBox">
<!-- A "type as you go" search box implementation,
an example of more complicated HTML and JS behavior -->
<Template>
<p>Type a book name for "search as you type"
(e.g. try &ldquo;the lord of the rings&rdquo;)</p>

<input [state.bind] name="search"
  @keyup:=script.typingCallback />

<div class="results {% if state.search.length gt 0 %}
                      visible {% endif %}">
  <div class="results-container">
    {% if state.loading %}
      <img src="{{ staticdata.gif }}" alt="loading" />
    {% else %}
      {% for result in state.results %}
        <div class="result">
          <img
            src="{{ staticdata.cover|add:result.cover_i }}-S.jpg"
          /> <label>{{ result.title }}</label>
        </div>
      {% empty %}
        <p>No books found.</p>
      {% endfor %}
    {% endif %}
  </div>
</div>
</Template>

<State
    search=""
    results:=[]
    loading:=false
></State>

<!-- Puting long URLs down here to declutter -->
<StaticData>
{
  apiBase: 'https://openlibrary.org/search.json',
  cover: 'https://covers.openlibrary.org/b/id/',
  gif: 'https://cdnjs.cloudflare.com/ajax/libs/' +
    'semantic-ui/0.16.1/images/loader-large.gif'
}
</StaticData>

<Script>
    function typingCallback() {
        state.loading = true;
        const search = `q=${state.search}`;
        const opts = 'limit=6&fields=title,author_name,cover_i';
        const url = `${staticdata.apiBase}?${search}&${opts}`;
        _globalDebounce(() => {
            fetch(url)
                .then(response => response.json())
                .then(dataBackCallback);
        });
    }

    function dataBackCallback(data) {
        state.results = data.docs;
        state.loading = false;
        element.rerender();
    }

    let _globalDebounceTimeout = null;
    function _globalDebounce(func) {
        if (_globalDebounceTimeout) {
            clearTimeout(_globalDebounceTimeout);
        }
        _globalDebounceTimeout = setTimeout(func, 500);
    }
</Script>

<Style>
    input { width: 120px; }
    .results-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
    }
    .results-container > img { margin-top 30px; }
    .results {
        position: absolute;
        height: 0;
        width: 0;
        overflow: hidden;
        display: block;
        border: 2px solid coral;
        border-radius: 0 0 20px 20px;
        transition: height 0.2s;
        z-index: 20;
        background: white;
    }
    .results.visible {
        height: 200px;
        width: 200px;
    }
    .result {
        padding: 10px;
        width: 80px;
        position: relative;
    }
    .result label {
        position: absolute;
        width: 80px;
        background: rgba(255, 255, 255, 0.5);
        font-size: 0.7rem;
        top: 0;
        left: 0;
    }
</Style>

<testsuite
    src="./examplelib-tests/SearchBox-tests.html"
></testsuite>

</component>






<component name="PrimeSieve">
<!-- Demos mouseover, template filters, template control flow,
     and static script exports -->
<Template>
  <div class="grid">
    {% for i in script.exports.range %}
      <div @mouseover:=script.setNum
        class="
            {# If-statements to check divisibility in template: #}
            {% if state.number == i %}number{% endif %}
            {% if state.number lt i %}hidden{% else %}
              {% if state.number|divisibleby:i %}whole{% endif %}
            {% endif %}
        ">{{ i }}</div>
    {% endfor %}
  </div>
</Template>

<State
    number:=64
></State>

<Script>
    // Getting big a range of numbers in JS. Use "script.exports"
    // to export this as a one-time global constant.
    // (Hint: Curious how it calculates prime? See CSS!)
    script.exports.range = 
        Array.from({length: 63}, (x, i) => i + 2);
    function setNum(payload, ev) {
        state.number = Number(ev.target.textContent);
    }
</Script>

<Style>
.grid {
    display: grid;
    grid-template-columns: repeat(9, 1fr);
    color: #ccc;
    font-weight: bold;
    width: 100%;
    margin: -5px;
}
.grid > div {
    border: 1px solid #ccc;
    cursor: crosshair;
    transition: 0.2s;
}
div.whole {
    color: white;
    background: #B90183;
}
div.hidden {
    background: #ccc;
    color: #ccc;
}

/* Color green and add asterisk */
div.number { background: green; }
div.number::after { content: "*"; }
/* Check for whole factors (an adjacent div.whole).
   If found, then hide asterisk and green */
div.whole ~ div.number { background: #B90183; }
div.whole ~ div.number::after { opacity: 0; }
</Style>

<testsuite
    src="./examplelib-tests/PrimeSieve-tests.html"
></testsuite>

</component>





<component name="MemoryGame">
<!-- A much more complicated example application -->
<Template>
{% if not state.cards.length %}
    <h3>The Symbolic Memory Game</h3>
    <p>Choose your difficulty:</p>
    <button @click:=script.setup click.payload=8>2x4</button>
    <button @click:=script.setup click.payload=16>4x4</button>
    <button @click:=script.setup click.payload=36>6x6</button>
{% else %}
    <div class="board
        {% if state.cards.length > 16 %}hard{% endif %}">
    {# Loop through each card in the "deck" (state.cards) #}
    {% for card in state.cards %}
        {# Use "key=" to speed up DOM reconciler #}
        <div key="c{{ card.id }}"
            class="card
            {% if card.id in state.revealed %}
                flipped
            {% endif %}
            "
            style="
            {% if state.win %}
                animation: flipping 0.5s infinite alternate;
                animation-delay: {{ card.id }}.{{ card.id }}s;
            {% endif %}
            "
            @click:=script.flip
            click.payload="{{ card.id }}">
            {% if card.id in state.revealed %}
                {{ card.symbol }}
            {% endif %}
        </div>
    {% endfor %}
    </div>
    <p style="{% if state.failedflip %}
                color: red{% endif %}">
        {{ state.message }}</p>
{% endif %}
</Template>

<State
    message="Good luck!"
    win:=false
    cards:=[]
    revealed:=[]
    lastflipped:=null
    failedflip:=null
></State>

<Script>
const symbolsStr = "%!@#=?&+~÷≠∑µ‰∂Δƒσ"; // 16 options
function setup(payload) {
    const count = Number(payload);
    let symbols = symbolsStr.substr(0, count/2).split("");
    symbols = symbols.concat(symbols); // duplicate cards
    let id = 0;
    while (id < count) {
        const index = Math.floor(Math.random()
                                    * symbols.length);
        const symbol = symbols.splice(index, 1)[0];
        state.cards.push({symbol, id});
        id++;
    }
}

function failedFlipCallback() {
    // Remove both from revealed array & set to null
    state.revealed = state.revealed.filter(
            id => id !== state.failedflip
                    && id !== state.lastflipped);
    state.failedflip = null;
    state.lastflipped = null;
    state.message = "";
    element.rerender();
}

function flip(id) {
    if (state.failedflip !== null) {
        return;
    }
    id = Number(id);
    if (state.revealed.includes(id)) {
        return; // double click
    } else if (state.lastflipped === null) {
        state.lastflipped = id;
        state.revealed.push(id);
    } else {
        state.revealed.push(id);
        const {symbol} = state.cards[id];
        const lastCard = state.cards[state.lastflipped];
        if (symbol === lastCard.symbol) {
            // Successful match! Check for win.
            const {revealed, cards} = state;
            if (revealed.length === cards.length) {
                state.message = "You win!";
                state.win = true;
            } else {
                state.message = "Nice match!";
            }
            state.lastflipped = null;
        } else {
            state.message = "No match.";
            state.failedflip = id;
            setTimeout(failedFlipCallback, 1000);
        }
    }
}
</Script>

<Style>
h3 {
    background: #B90183;
    border-radius: 8px;
    text-align: center;
    color: white;
    font-weight: bold;
}
.board {
    display: grid;
    grid-template-rows: repeat(4, 1fr);
    grid-template-columns: repeat(4, 1fr);
    grid-gap: 2px;
    width: 100%;
    height: 150px;
    width: 150px;
}
.board.hard {
    grid-gap: 1px;
    grid-template-rows: repeat(6, 1fr);
    grid-template-columns: repeat(6, 1fr);
}
.board > .card {
    background: #B90183;
    border: 2px solid black;
    border-radius: 1px;
    cursor: pointer;
    text-align: center;
    min-height: 15px;
    transition: background 0.3s, transform 0.3s;
    transform: scaleX(-1);
    padding-top: 2px;
    color: #B90183;
}
.board.hard > .card {
    border: none !important;
    padding: 0;
}
.board > .card.flipped {
    background: #FFFFFF;
    border: 2px solid #B90183;
    transform: scaleX(1);
}

@keyframes flipping {
    from { transform: scaleX(-1.1); background: #B90183; }
    to {   transform: scaleX(1.0);  background: #FFFFFF; }
}
</Style>

<testsuite
    src="./examplelib-tests/MemoryGame-tests.html"
></testsuite>

</component>




<component name="ConwayGameOfLife">
<Template>
  <div class="grid">
    {% for i in script.exports.range %}
        {% for j in script.exports.range %}
          <div
            @click:=script.toggle
            payload:='[ {{ i }}, {{ j }} ]'
            {% if state.cells|get:i %}
                {% if state.cells|get:i|get:j %}
                    style="background: #B90183;"
                {% endif %}
            {% endif %}
           ></div>
        {% endfor %}
    {% endfor %}
  </div>
  <div class="controls">
    {% if not state.playing %}
        <button @click:=script.play alt="Play">&#x25B6;</button>
    {% else %}
        <button @click:=script.pause alt="Pause">&#x2016;</button>
    {% endif %}

    <button @click:=script.randomize alt="Randomize">RND</button>
    <button @click:=script.clear alt="Randomize">CLR</button>
    <label>Spd: <input [state.bind]
        name="speed"
        type="number" min="1" max="10" step="1" /></label>
  </div>
</Template>

<State
    playing:=false
    speed:=3
    cells:='{
        "12": { "10": true, "11": true, "12": true },
        "11": { "12": true },
        "10": { "11": true }
    }'
></State>

<Script>
    function toggle([ i, j ]) {
        if (!state.cells[i]) {
            state.cells[i] = {};
        }
        state.cells[i][j] = !state.cells[i][j];
    }

    function play() {
        state.playing = true;
        setTimeout(() => {
            if (state.playing) {
                updateNextFrame();
                element.rerender(); // manually rerender
                play(); // cue next frame
            }
        }, 2000 / state.speed);
    }

    function pause() {
        state.playing = false;
    }

    function clear() {
        state.cells = {};
    }

    function randomize() {
        for (const i of script.exports.range) {
            for (const j of script.exports.range) {
                if (!state.cells[i]) {
                    state.cells[i] = {};
                }
                state.cells[i][j] = (Math.random() > 0.5);
            }
        }
    }

    // Helper function for getting a cell from data
    const get = (i, j) => Boolean(state.cells[i] && state.cells[i][j]);
    function updateNextFrame() {
        const nextData = {};
        for (const i of script.exports.range) {
            for (const j of script.exports.range) {
                if (!nextData[i]) {
                    nextData[i] = {};
                }
                const count = countNeighbors(i, j);
                nextData[i][j] = get(i, j) ?
                    (count === 2 || count === 3) : // stays alive
                    (count === 3); // comes alive
            }
        }
        state.cells = nextData;
    }

    function countNeighbors(i, j) {
        const neighbors = [get(i - 1, j), get(i - 1, j - 1), get(i, j - 1),
                get(i + 1, j), get(i + 1, j + 1), get(i, j + 1),
                get(i + 1, j - 1), get(i - 1, j + 1)];
        return neighbors.filter(v => v).length;
    }
    script.exports.range = Array.from({length: 24}, (x, i) => i);
</Script>

<Style>
    :host {
        display: flex;
    }
    .grid {
        display: grid;
        grid-template-columns: repeat(24, 5px);
        margin: -2px;
        grid-gap: 1px;
    }
    .grid > div {
        background: white;
        width: 5px;
        height: 5px;
    }
    input, button {
        width: 40px;
    }
</Style>

</component>

