<!DOCTYPE HTML><head>
    <meta charset="utf8">
    <title>Source - Modulo.js</title>
    <link rel="stylesheet" media="all" href="../modified_parallel_docco.css"> <!-- for doccu css -->
    <link rel="stylesheet" href="../../css/style.css">
    <link rel="icon" type="image/png" href="../../img/mono_logo.png">
    <script src="../../js/Modulo.js"></script>
    <style id="mdu-TabSet_style">
mdu-TabSet {
            width: 100%;
            display: flex;
            flex-direction: column;
            /*border: 1px dotted var(--highlight-color);*/
            /*border-top: 1px dotted black;*/
        }
mdu-TabSet .tab-nav {
            /*border-bottom: 1px dotted var(--highlight-color);*/
            width: 100%;
        }
mdu-TabSet .tab-nav > ul {
            width: 100%;
            display: flex;
        }
mdu-TabSet .tab-nav_title {
            border: 2px solid black;
            border-top-width: 4px;
            border-bottom-width: 0;
            border-radius: 8px 8px 0 0;
            background: white;
            min-width: 10%;
        }

mdu-TabSet .tab-nav_title a,
mdu-TabSet .tab-nav_title a:visited,
mdu-TabSet .tab-nav_title a:active {
            text-decoration: none;
            color: black;
            display: block;
            padding: 5px;
            font-weight: bold;
            cursor: pointer;
        }

mdu-TabSet .tab-nav_title__selected {
            background: var(--highlight-color);
            box-shadow: 0 0 0 5px var(--highlight-color);
            padding-top: 3px;
            border-top-width: 1px;
            border-radius: 1px;
        }
    </style><style id="mdu-CodeExample_style">
mdu-CodeExample .toolbar {
            display: flex;
            justify-content: space-between;
        }
mdu-CodeExample .toolbar > button {
            border: 2px solid black;
            border-top-width: 1px;
            border-bottom-width: 3px;
            border-radius: 3px;
            background: white;
            font-weight: lighter;
            text-transform: uppercase;
        }
mdu-CodeExample .toolbar > button:active {
            border-top-width: 3px;
            border-bottom-width: 1px;
        }
mdu-CodeExample .toolbar > button:hover {
            box-shadow: 0 0 2px var(--highlight-color); /* extremely subtle shadow */
        }
mdu-CodeExample .split > div:last-child {
            padding: 5px;
            background: whiteSmoke;
        }
mdu-CodeExample .split > div:first-child{
            border: 1px solid black;
            height: 172px;
            /*overflow-y: scroll;*/
        }

mdu-CodeExample .preview-wrapper {
            margin-top: 4px;
            padding: 5px;
            padding-left: 20px;
            padding-right: 20px;
            border: 1px solid black;
        }

mdu-CodeExample .split > div > textarea {
            width: 100%;
            min-height: 10px;
        }
mdu-CodeExample .split {
            display: grid;
            grid-template-columns: 2fr 1fr;
        }
@media (max-width: 992px) {
mdu-CodeExample .split { display: block; }
        }
    </style></head><body><mod-load namespace="mdu" src="../../components/core.html"></mod-load>
    <mod-load namespace="mdu" src="../../components/pageparts.html"></mod-load>



  <mdu-navbar selected="source" script-exports="{&quot;version&quot;:&quot;0.0.1&quot;,&quot;sloc&quot;:876}">
        <nav class="Navbar">
            <a href="index.html"><img src="/img/mono_logo.png" style="height:70px" alt="Modulo"></a>
            <ul>
                <li>
                    <a href="/index.html#below">About</a>
                </li>
                <li>
                    <a href="/start.html">Start</a>
                </li>
                <li>
                    <a href="/docs.html">Docs</a>
                </li>
                <li>
                    <a href="/literate/src/Modulo.html" class="Navbar--selected">Source</a>
                </li>
            </ul>

            <div class="Navbar-rightInfo">
                v: 0.0.1<br>
                SLOC: 876 lines<br>
                <a href="https://github.com/michaelpb/modulo/">github</a> | 
                <a href="https://npmjs.com/michaelpb/modulo/">npm</a> 
            </div>
        </nav>
    </mdu-navbar>
  <script>Modulo.defineAll();</script>

  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">§</a>
              </div>
              <h1 id="introduction">Introduction</h1>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">§</a>
              </div>
              <p>Welcome to the Modulo.js source code.</p>
<p>Unlike most code files, this one is arranged in a very deliberate way.  It’s
arranged in a top-down manner, reflecting the “lifecycle” of a Modulo
component, such that the earlier and more important code is at the top, and
later and less important code is at the bottom. You can read it like a
linear “story” of how Modulo works. Modulo employs <a href="https://en.wikipedia.org/wiki/Literate_programming">literate
programming</a>, or
interweaving Markdown-formatted comments on to tell this story, and uses a
tool (docco) to extract all these comments for easy reading.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> HTMLElement === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">var</span> HTMLElement = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>{}; <span class="hljs-comment">// Node.js compatibilty</span>
}
<span class="hljs-keyword">var</span> Modulo = {
    <span class="hljs-attr">globals</span>: {HTMLElement}, <span class="hljs-comment">// globals is window in Browser, an obj in Node.js</span>
    <span class="hljs-attr">reconcilers</span>: {}, <span class="hljs-comment">// used later, for custom DOM Reconciler classes</span>
    <span class="hljs-attr">cparts</span>: {}, <span class="hljs-comment">// used later, for custom CPart classes</span>
    <span class="hljs-attr">templating</span>: {}, <span class="hljs-comment">// used later, for custom Templating languages</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">§</a>
              </div>
              <h2 id="code-standards">Code standards</h2>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">§</a>
              </div>
              <ul>
<li>SLOC limit: 1000 lines</li>
<li>Line limit: 80 chars</li>
<li>Indentation: 4 spaces</li>
</ul>
<h2 id="quick-definitions">Quick definitions:</h2>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">§</a>
              </div>
              <ul>
<li>Component - A discrete, re-usable bit of code, typically used to show a
graphical UI element (eg a button, or a rich-text area). Components can
also use other components (eg a form).</li>
<li>ComponentPart, or CPart - Each component consists of a “bag” or “bundle”
of CParts, each CPart being a “pluggable” module that supplies different</li>
<li>functionality for that component.</li>
<li>customElement - The term used for a custom HTML5 web component</li>
<li>Modulo.globals - Identical to “window”, helps keep unit-tests simpler</li>
</ul>
<h2 id="lifecycle-toc">Lifecycle ToC:</h2>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">§</a>
              </div>
              <h3 id="group-1-preparation">Group 1: Preparation</h3>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">§</a>
              </div>
              <p>These happen once per component definition (in the case of <code>load</code> and
<code>factory</code>), or once per component usage (in the case of <code>initialized</code>)</p>
<ul>
<li><code>load</code> - the stage of parsing a code file (eg static analysis). Note that<pre><code>     <span class="hljs-keyword">if</span> a Modulo-based project is compiled into a single JS file, <span class="hljs-built_in">this</span>
     <span class="hljs-string">`load`</span> happens BEFORE, and thus gets <span class="hljs-string">"baked-in"</span>.
</code></pre>
</li>
<li><code>factory</code> - any one-time, global set-up for a component (e.g. compiling the template)</li>
<li><code>initialized</code> - happens once, every time a component is used (mounted) on the page</li>
</ul>
<h3 id="group-2-rendering">Group 2: Rendering</h3>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">§</a>
              </div>
              <p>These get repeated every time a component is rendered or rendered.</p>
<ul>
<li><code>prepare</code> - Gather data needed before rendering (e.g. gather variables for
template)</li>
<li><code>render</code> - Use the Template to render HTML code</li>
<li><code>update</code> - Updates the DOM to reflect the newly generated HTML code, while
 applying directives. Each directive gets it’s own set of lifecycle
 methods, like eventMount and eventUnmount.</li>
<li><code>updated</code> - Perform any clean-up tasks after DOM update</li>
</ul>
<h3 id="group-3-directives">Group 3: Directives</h3>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">§</a>
              </div>
              <ul>
<li><code>event</code> &amp; <code>eventCleanup</code> - Handle @click or @keyup events</li>
<li><code>resolve</code> - Handle resolving value set with =:</li>
</ul>
<h2 id="modulodefineall">Modulo.defineAll()</h2>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">§</a>
              </div>
              <p>Our Modulo journey begins with <code>Modulo.defineAll()</code>, the function invoked to
“activate” all of Modulo by defining the “mod-load” web component. This
constructs a Loader object for every <code>&lt;mod-load ...&gt;</code> tag it encounters.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.defineAll = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineAll</span>(<span class="hljs-params"></span>) </span>{
    Modulo.globals.customElements.define(<span class="hljs-string">'mod-load'</span>, Modulo.Loader);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">§</a>
              </div>
              <h1 id="moduloloader">Modulo.Loader</h1>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">§</a>
              </div>
              <p>Once registered by <code>defineAll()</code>, the <code>Modulo.Loader</code> will do the rest of
the heavy lifting of fetching &amp; registering Modulo components.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.Loader = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">§</a>
              </div>
              <h2 id="loader-connectedcallback">Loader: connectedCallback()</h2>

            </div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">§</a>
              </div>
              <p>The Web Components specifies the use of a “connectedCallback” function.
In this case, this function will be invoked as soon as the DOM is loaded
with a <code>&lt;mod-load&gt;</code> tag in it.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">connectedCallback</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.src = <span class="hljs-built_in">this</span>.getAttribute(<span class="hljs-string">'src'</span>);
        <span class="hljs-built_in">this</span>.namespace = <span class="hljs-built_in">this</span>.getAttribute(<span class="hljs-string">'namespace'</span>);
        Modulo.assert(<span class="hljs-built_in">this</span>.src, <span class="hljs-string">'Loader: Invalid or missing src= attribute'</span>);
        Modulo.assert(<span class="hljs-built_in">this</span>.namespace, <span class="hljs-string">'Loader: Invalid or missing namespace= attribute'</span>);

        <span class="hljs-built_in">this</span>.cacheKey = <span class="hljs-string">`Modulo.Loader:cache:<span class="hljs-subst">${<span class="hljs-built_in">this</span>.namespace}</span>:<span class="hljs-subst">${<span class="hljs-built_in">this</span>.src}</span>`</span>;
        <span class="hljs-keyword">const</span> cachedData = Modulo.globals.localStorage.getItem(<span class="hljs-built_in">this</span>.cacheKey);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">§</a>
              </div>
              <p>TODO: Finish cache feature, maybe fold into hot reload, eg it always
first loads from cache, then it tries hotreloading from origin.
This would make “never-cache” less important, but “always-cache”
would be useful and be the inverse.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> skipCache = <span class="hljs-literal">true</span> || <span class="hljs-built_in">this</span>.hasAttribute(<span class="hljs-string">'never-cache'</span>) || Modulo.require;
        <span class="hljs-keyword">if</span> (!skipCache &amp;&amp; cachedData &amp;&amp; cachedData.length &gt; <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [name, loadObj] <span class="hljs-keyword">of</span> <span class="hljs-built_in">JSON</span>.parse(cachedData)) {
                <span class="hljs-built_in">this</span>.defineComponent(name, loadObj);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* 
                if (this.getAttribute('reload')) {
                    setInterval(this.doFetch, 2000);
                }
            */</span>
            <span class="hljs-built_in">this</span>.doFetch();
        }
    }

    <span class="hljs-function"><span class="hljs-title">doFetch</span>(<span class="hljs-params"></span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">§</a>
              </div>
              <p>After initializing data, send a new request to the URL specified by
the src attribute. When the response is received, load the text as a
Modulo component module definition.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        Modulo.globals.fetch(<span class="hljs-built_in">this</span>.src)
            .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.text())
            .then(<span class="hljs-function"><span class="hljs-params">text</span> =&gt;</span> <span class="hljs-built_in">this</span>.loadString(text))
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-17">§</a>
              </div>
              <h2 id="loader-loadstring">Loader: loadString</h2>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-18">§</a>
              </div>
              <p>The main loading method. This will take a string with the source code to
a module as an argument and loop through all <code>&lt;component ...&gt;</code> style
definitions. Then, it uses <code>Loader.loadFromDOMElement</code> to create a
<code>ComponentFactory</code> instance for each component definition.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">loadString</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-comment">/* TODO - Maybe use DOMParser here instead */</span>
        <span class="hljs-comment">/* TODO - Recurse into other sub-loaders, applying namespace */</span>
        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> Do &lt;script  / etc preprocessing here:
          &lt;state -&gt; &lt;script type="modulo/state"
          &lt;\s*(state|props|template)([\s&gt;]) -&gt; &lt;script type="modulo/\1"\2
          &lt;/(state|props|template)&gt; -&gt; &lt;/script&gt;
        */</span>
        <span class="hljs-keyword">const</span> frag = <span class="hljs-keyword">new</span> Modulo.globals.DocumentFragment();
        <span class="hljs-keyword">const</span> div = Modulo.globals.document.createElement(<span class="hljs-string">'div'</span>);
        <span class="hljs-built_in">this</span>.factoryData = [];
        div.innerHTML = text;
        frag.append(div);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> tag <span class="hljs-keyword">of</span> div.querySelectorAll(<span class="hljs-string">'[mod-component],component'</span>)) {
            <span class="hljs-keyword">const</span> [name, loadObj] = <span class="hljs-built_in">this</span>.loadFromDOMElement(tag);
            <span class="hljs-built_in">this</span>.factoryData.push([name, loadObj]);
            <span class="hljs-built_in">this</span>.defineComponent(name, loadObj);
        }
        <span class="hljs-keyword">const</span> serialized = <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-built_in">this</span>.factoryData);
        Modulo.globals.localStorage.setItem(<span class="hljs-built_in">this</span>.cacheKey, serialized);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-19">§</a>
              </div>
              <h2 id="loader-loadfromdomelement">Loader: loadFromDOMElement</h2>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-20">§</a>
              </div>
              <p>Create a ComponentFactory instance from a given <code>&lt;component&gt;</code> definition.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">loadFromDOMElement</span>(<span class="hljs-params">elem</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-21">§</a>
              </div>
              <h3 id="step-1-config">Step 1: Config</h3>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-22">§</a>
              </div>
              <p>Get any custom component configuration (e.g. attributes <code>name=</code> or
<code>extends=</code>)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> attrs = Modulo.utils.parseAttrs(elem);
        <span class="hljs-keyword">const</span> name = attrs.modComponent || attrs.name;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-23">§</a>
              </div>
              <h3 id="step-2-set-up-loadobj">Step 2: Set-up <code>loadObj</code></h3>

            </div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-24">§</a>
              </div>
              <p>Modulo often uses plain objects to “pass around” during the lifecycle
of each component. At this stage, we set up <code>loadObj</code>.</p>
<p>At the end of this method, the loadObj will be populated with a
complete, parsed, component definition – enough information to
instantiate a “factory” for this component – in the following
structure:</p>
<pre><code class="language-javascript">loadObj = {
    <span class="hljs-attr">template</span>: [...], <span class="hljs-comment">// array of parsed objects for "Template" CPart</span>
    <span class="hljs-attr">state</span>: [...], <span class="hljs-comment">// array of parsed objects for "State" CPart</span>
    ...etc
}
</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> loadObj = {<span class="hljs-attr">component</span>: [{name}]}; <span class="hljs-comment">// Everything gets implicit Component CPart</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-25">§</a>
              </div>
              <h3 id="step-3-define-cparts">Step 3: define CParts</h3>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-26">§</a>
              </div>
              <p>Loop through each CPart DOM definition within the component (e.g.
<code>&lt;state&gt;</code>), invoking the <code>loadCallback</code> on each definition (e.g.
<code>Modulo.cparts.state.loadCallback</code> will get invoked for each
<code>&lt;state&gt;</code>). This <code>loadCallback</code> in turn will do any pre-processing
necessary to transform the attributes of the DOM element into the
data necessary to define this CPart.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> {cPartName, node} <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.getCPartNamesFromDOM(elem)) {
            <span class="hljs-keyword">if</span> (!(cPartName <span class="hljs-keyword">in</span> loadObj)) {
                loadObj[cPartName] = [];
            }
            <span class="hljs-keyword">const</span> {loadCallback} = Modulo.cparts[cPartName];
            loadObj[cPartName].push(loadCallback(node, <span class="hljs-built_in">this</span>, loadObj));
        }
        <span class="hljs-keyword">return</span> [name, loadObj];
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-27">§</a>
              </div>
              <h2 id="loader-definecomponent">Loader: defineComponent</h2>

            </div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-28">§</a>
              </div>
              <p>Helper function that constructs a new ComponentFactory for a component,
based on a loadObj data structure.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">defineComponent</span>(<span class="hljs-params">name, loadObj</span>)</span> {
        <span class="hljs-keyword">const</span> factory = <span class="hljs-keyword">new</span> Modulo.ComponentFactory(<span class="hljs-built_in">this</span>, name, loadObj);
        factory.register();
        <span class="hljs-keyword">if</span> (Modulo.globals.defineComponentCallback) {
            Modulo.globals.defineComponentCallback(factory); <span class="hljs-comment">// TODO rm when possible</span>
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-29">§</a>
              </div>
              <h2 id="loadergetnodecpartname">Loader.getNodeCPartName</h2>

            </div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-30">§</a>
              </div>
              <p>Helper function that determines the CPart name from a DOM node.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">getNodeCPartName</span>(<span class="hljs-params">node</span>)</span> {
        <span class="hljs-keyword">const</span> {tagName, nodeType, textContent} = node;</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-31">§</a>
              </div>
              <p>node.nodeType equals 1 if the node is a DOM element (as opposed to
text, or comment). Ignore comments, tolerate empty text nodes, but
warn on others (since those are typically syntax mistakes).</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">if</span> (nodeType !== <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-32">§</a>
              </div>
              <p>Text nodes, comment nodes, etc</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-number">3</span> &amp;&amp; textContent &amp;&amp; textContent.trim()) {
                <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unexpected text in component def:'</span>, textContent);
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-33">§</a>
              </div>
              <p>Determine the name: The tag name, or the type attribute in the case
of the alt script-tag syntax (eg <code>&lt;script type="modulo/template"&gt;</code>)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">let</span> cPartName = tagName.toLowerCase();
        <span class="hljs-keyword">const</span> splitType = (node.getAttribute(<span class="hljs-string">'type'</span>) || <span class="hljs-string">''</span>).split(<span class="hljs-string">'/'</span>);
        <span class="hljs-keyword">if</span> (splitType[<span class="hljs-number">0</span>] &amp;&amp; splitType[<span class="hljs-number">0</span>].toLowerCase() === <span class="hljs-string">'modulo'</span>) {
            cPartName = splitType[<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">if</span> (!(cPartName <span class="hljs-keyword">in</span> Modulo.cparts)) {
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unknown CPart in component def:'</span>, tagName);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">return</span> cPartName;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-34">§</a>
              </div>
              <h2 id="loadergetcpartnamesfromdom">Loader.getCPartNamesFromDOM</h2>

            </div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-35">§</a>
              </div>
              <p>Helper function that loops through a component definitions children,
generating an array of objects containing the node and CPart name.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">getCPartNamesFromDOM</span>(<span class="hljs-params">elem</span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(elem.content.childNodes)
            .map(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> ({node, <span class="hljs-attr">cPartName</span>: <span class="hljs-built_in">this</span>.getNodeCPartName(node)}))
            .filter(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj.cPartName);

        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> rewrite this */</span>
        <span class="hljs-keyword">const</span> arr = [];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> node <span class="hljs-keyword">of</span> elem.content.childNodes) {
            <span class="hljs-keyword">const</span> cPartName = <span class="hljs-built_in">this</span>.getNodeCPartName(node);
            <span class="hljs-keyword">if</span> (cPartName) {
                arr.push({node, cPartName});
            }
        }
        <span class="hljs-keyword">return</span> arr;
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-36">§</a>
              </div>
              <h1 id="modulocomponentfactory">Modulo.ComponentFactory</h1>

            </div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-37">§</a>
              </div>
              <p>Now that we have traversed the jungle of loading Modulo component
definitions, what happens next? Well, for each component that is defined, a
ComponentFactory instance is created. This class handles instantiating and
setting up Modulo components whenever they are encountered on an HTML page.</p>
<p>In Modulo, every component definition consists of a collection of CPart
configurations. Thus, the ComponentFactory stores the configuration of the
CParts.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.ComponentFactory = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentFactory</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-38">§</a>
              </div>
              <h2 id="componentfactory-constructor">ComponentFactory constructor</h2>

            </div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-39">§</a>
              </div>
              <p>When a ComponentFactory gets constructed (that is, by the Loader), it in
turn sets up expected properties, and then invokes its methods
createClass and runFactoryLifeCycle explained next.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">loader, name, options</span>)</span> {
        <span class="hljs-built_in">this</span>.loader = loader;
        <span class="hljs-built_in">this</span>.options = options;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.fullName = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">this</span>.loader.namespace}</span>-<span class="hljs-subst">${name}</span>`</span>;
        Modulo.ComponentFactory.registerInstance(<span class="hljs-built_in">this</span>);
        <span class="hljs-built_in">this</span>.componentClass = <span class="hljs-built_in">this</span>.createClass();
        <span class="hljs-built_in">this</span>.baseRenderObj = <span class="hljs-built_in">this</span>.runFactoryLifecycle(options);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-40">§</a>
              </div>
              <h2 id="componentfactory-factory-lifecycle">ComponentFactory: Factory lifecycle</h2>

            </div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-41">§</a>
              </div>
              <p>This “factory” lifecycle is a special lifecycle for any global or
one-time setup, after component definitions are loaded, but before
before any components are constructed. Examples: the Style CPart uses
this stage to set up global CSS, the Template CPart uses this to compile
the template, and the Script CPart will actually wrap the script-tag &amp;
invoke it now.</p>
<p>Like every other “lifecycle” in Modulo, it passes around a “renderObj”
called baseRenderObj. After this method, this baseRenderObj is not
modified, but instead gets copied into every other renderObj to form, as
the name implies, the “base” of future renderObj.</p>
<p>In total, this method loops through all the CPart names, finding each
relevant CPart Classes, and then invoking each CPart static method
“factoryCallback”, which is what does the necessary preprocessing. If
there are multiples of the same CPart, then whichever appears last will
overwrite and/or merge data with the previous ones.  However, that
particular behavior can be controlled from within each CPart
factoryCallback itself.</p>
<p>At the end of this method, baseRenderObj will look like this:</p>
<pre><code class="language-javascript"><span class="hljs-built_in">this</span>.baseRenderObj = {
    <span class="hljs-attr">script</span>: {<span class="hljs-attr">text</span>: <span class="hljs-string">'"use static"\nvar state;\nfunction inpCh(....etc)'</span>},
    <span class="hljs-attr">template</span>: {<span class="hljs-attr">compiledTemplate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ ...etc... }},
    (...etc...)
}
</code></pre>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">runFactoryLifecycle</span>(<span class="hljs-params">cPartOpts</span>)</span> {
        <span class="hljs-keyword">const</span> baseRenderObj = {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [cPartName, partOptionsArr] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(cPartOpts)) {
            <span class="hljs-keyword">const</span> cpCls = Modulo.cparts[cPartName];
            <span class="hljs-keyword">let</span> data = {};
            <span class="hljs-keyword">for</span> (data <span class="hljs-keyword">of</span> partOptionsArr) {
                data = cpCls.factoryCallback(data, <span class="hljs-built_in">this</span>, baseRenderObj) || data;
            }
            baseRenderObj[cPartName] = data;
        }
        <span class="hljs-keyword">return</span> baseRenderObj;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-42">§</a>
              </div>
              <h2 id="componentfactory-createclass">ComponentFactory: createClass</h2>

            </div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-43">§</a>
              </div>
              <p>Finally, we are ready to create the class that the browser will use to
actually instantiate each Component. At this stage, we set up the
reconciliation engine, since that’s a component-wide option, create a
“back reference” to the factory from the component, and then return a
brand-new class definition.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">createClass</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">const</span> {fullName} = <span class="hljs-built_in">this</span>;
        <span class="hljs-keyword">const</span> {reconciliationEngine = <span class="hljs-string">'SetDom'</span>} = <span class="hljs-built_in">this</span>.options;
        <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">new</span> Modulo.reconcilers[reconciliationEngine]();
        <span class="hljs-keyword">const</span> func = <span class="hljs-function">(<span class="hljs-params">component, html</span>) =&gt;</span> engine.reconcile(component, html);
        <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">Element</span> </span>{
            <span class="hljs-keyword">get</span> <span class="hljs-title">factory</span>() {
                <span class="hljs-comment">/* Gets current registered component factory (for hot-reloading) */</span>
                <span class="hljs-keyword">return</span> Modulo.factoryInstances[fullName];
            }
            <span class="hljs-keyword">get</span> <span class="hljs-title">reconcile</span>() { <span class="hljs-keyword">return</span> func; }
        };
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-44">§</a>
              </div>
              <h2 id="componentfactory-buildcparts">ComponentFactory: buildCParts</h2>

            </div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-45">§</a>
              </div>
              <p>This function does the heavy lifting of actually constructing a
component, and is invoked when the component is mounted to the page.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">buildCParts</span>(<span class="hljs-params">element</span>)</span> {
        <span class="hljs-keyword">const</span> oldCParts = element.cparts || {};
        element.cparts = {element}; <span class="hljs-comment">// Include "element", for lifecycle methods</span>
        element.cpartSpares = {}; <span class="hljs-comment">// no need to include, since only 1 element</span></pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-46">§</a>
              </div>
              <p>It loops through the parsed array of objects that define the
Component Parts for this component, checking for errors.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [name, partOptionsArr] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(<span class="hljs-built_in">this</span>.options)) {
            Modulo.assert(name <span class="hljs-keyword">in</span> Modulo.cparts, <span class="hljs-string">`Unknown cPart: <span class="hljs-subst">${name}</span>`</span>);
            element.cpartSpares[name] = [];

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> partOptions <span class="hljs-keyword">of</span> partOptionsArr) {
                <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Modulo.cparts[name](element, partOptions);
                <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> element.cparts) {
                    element.cpartSpares[name].push(instance);
                }
                element.cparts[name] = instance;

                <span class="hljs-comment">/* // (<span class="hljs-doctag">NOTE:</span> Untested after refactor) 
                *  // If this component was already mounted and is getting
                *  // "rebuilt" due to the definition changing, it also triggers
                *  // any callbacks, to allow for hot-reloading without losing
                *  // state.
                if (cparts[name].reloadCallback &amp;&amp; name in oldCParts) {
                    cparts[name].reloadCallback(oldCParts[name]);
                }*/</span>
            }
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-47">§</a>
              </div>
              <h2 id="componentfactory-register--registerinstance">ComponentFactory: register &amp; registerInstance</h2>

            </div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-48">§</a>
              </div>
              <p>These are minor helper functions. The first registers with the browser,
the second keeps a central location of all component factories defined.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">register</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">const</span> tagName = <span class="hljs-built_in">this</span>.fullName.toLowerCase();
        Modulo.globals.customElements.define(tagName, <span class="hljs-built_in">this</span>.componentClass);
    }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">registerInstance</span>(<span class="hljs-params">instance</span>)</span> {
        <span class="hljs-keyword">if</span> (!Modulo.factoryInstances) {
            Modulo.factoryInstances = {};
        }
        Modulo.factoryInstances[instance.fullName] = instance;
    }
}

Modulo.Element = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuloElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">super</span>();
        <span class="hljs-built_in">this</span>.initialize();
    }

    <span class="hljs-function"><span class="hljs-title">initialize</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.cparts = {};

        <span class="hljs-built_in">this</span>.originalHTML = <span class="hljs-built_in">this</span>.innerHTML;
        <span class="hljs-built_in">this</span>.originalChildren = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-49">§</a>
              </div>
              <p>console.log(‘originalChildren!’, this.originalChildren);
console.log(‘originalInnerHTML!’, this.innerHTML);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasChildNodes()) {
            <span class="hljs-keyword">const</span> dupedChildren = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">this</span>.childNodes); <span class="hljs-comment">// necessary</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> dupedChildren) {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-50">§</a>
              </div>
              <p>this.originalChildren.push(this.removeChild(child)); // TODO: should i remove children?</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                <span class="hljs-built_in">this</span>.originalChildren.push(child);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-51">§</a>
              </div>
              <p>console.log(‘originalChildren has child nodes!’, this.originalChildren);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        }
        <span class="hljs-built_in">this</span>.fullName = <span class="hljs-built_in">this</span>.factory.fullName;
        <span class="hljs-built_in">this</span>.isMounted = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">this</span>.initRenderObj = <span class="hljs-built_in">Object</span>.assign({}, <span class="hljs-built_in">this</span>.factory.baseRenderObj);
    }

    <span class="hljs-function"><span class="hljs-title">setupCParts</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.factory.buildCParts(<span class="hljs-built_in">this</span>);
    }

    <span class="hljs-function"><span class="hljs-title">applyDirectives</span>(<span class="hljs-params">directives</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> args <span class="hljs-keyword">of</span> directives) {
            <span class="hljs-keyword">const</span> {setUp, tearDown, el, rawName, hasRun, value, dName} = args;
            <span class="hljs-keyword">if</span> (!setUp) {
                <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'TMP Skipping:'</span>, dName, rawName, value);
                <span class="hljs-keyword">continue</span>;
            }
            args.resolutionContext = <span class="hljs-built_in">this</span>; <span class="hljs-comment">// TODO fix this with truly predictable context</span>
            <span class="hljs-keyword">if</span> (hasRun) {
                <span class="hljs-keyword">if</span> (!tearDown) {
                    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'TMP NO TEAR DOWN ERR:'</span>, rawName);
                }
                tearDown(args);
            }
            args.hasRun = <span class="hljs-literal">true</span>;
            setUp(args);
            <span class="hljs-comment">/*
            if (setUp) {
                el.onload = setUp.bind(thisContext, [args]);
            }
            if (tearDown) {
                el.onunload = tearDown.bind(thisContext, [args]);
            }
            */</span>
        }
    }

    <span class="hljs-function"><span class="hljs-title">rerender</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.lifecycle([<span class="hljs-string">'prepare'</span>, <span class="hljs-string">'render'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'updated'</span>]);
    }

    <span class="hljs-function"><span class="hljs-title">lifecycle</span>(<span class="hljs-params">lifecycleNames, rObj={}</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-52">§</a>
              </div>
              <p>NEW CODE: This is a quick re-implementation of lifecycle</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-built_in">this</span>.renderObj = <span class="hljs-built_in">Object</span>.assign({}, rObj, <span class="hljs-built_in">this</span>.getCurrentRenderObj());</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-53">§</a>
              </div>
              <p>todo: maybe sort cparts ahead of time based on lifecycles?</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> lcName <span class="hljs-keyword">of</span> lifecycleNames) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [cPartName, cPart] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(<span class="hljs-built_in">this</span>.cparts)) {
                <span class="hljs-keyword">const</span> method = cPart[lcName + <span class="hljs-string">'Callback'</span>];
                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.renderObj) {
                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'lolwut - renderobj is falsy'</span>, <span class="hljs-built_in">this</span>.renderObj);
                    <span class="hljs-keyword">break</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-54">§</a>
              </div>
              <p>TODO: clean this up, renderObj should never “just”
be cPart, should be the whole cparts.* being bare
name OOP, vs cparts.*  being factory-defined</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                <span class="hljs-keyword">if</span> (!(cPartName <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.renderObj)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-55">§</a>
              </div>
              <p>this.renderObj[cPartName] = cPart;</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                }
                <span class="hljs-keyword">if</span> (method) {
                    <span class="hljs-keyword">const</span> results = method.call(cPart, <span class="hljs-built_in">this</span>.renderObj);
                    <span class="hljs-keyword">if</span> (results) {
                        <span class="hljs-built_in">this</span>.renderObj[cPartName] = results;
                    }
                }
            }
        }
        <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> should probably be nulling this after */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-56">§</a>
              </div>
              <p>this.renderObj = null; // rendering is over, set to null</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    }

    <span class="hljs-function"><span class="hljs-title">getCurrentRenderObj</span>(<span class="hljs-params"></span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-57">§</a>
              </div>
              <p>console.log(‘this is initRenderObj’, this.initRenderObj);
console.log(‘this is renderObj’, this.renderObj);
console.log(‘this is eventRenderObj’, this.eventRenderObj);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.eventRenderObj || <span class="hljs-built_in">this</span>.renderObj || <span class="hljs-built_in">this</span>.initRenderObj);
    }

    <span class="hljs-function"><span class="hljs-title">resolveValue</span>(<span class="hljs-params">key</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-58">§</a>
              </div>
              <p>const hackName = this.factory.name;
console.log(<code>   ${hackName} -- GET   ${key}</code>, rObj);
console.log(<code>   ${hackName} -- VALUE ${key} &lt;&lt;${result}&gt;&gt;</code>);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> rObj = <span class="hljs-built_in">this</span>.getCurrentRenderObj();
        <span class="hljs-keyword">const</span> result = key.split(<span class="hljs-string">'.'</span>).reduce(<span class="hljs-function">(<span class="hljs-params">o, name</span>) =&gt;</span> o[name], rObj);
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-function"><span class="hljs-title">resolveAttributeName</span>(<span class="hljs-params">name</span>)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasAttribute(name)) {
            <span class="hljs-keyword">return</span> name;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasAttribute(name + <span class="hljs-string">':'</span>)) {
            <span class="hljs-keyword">return</span> name + <span class="hljs-string">':'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-title">connectedCallback</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-comment">/*
        Note: For testability, setupCParts is invoked on first mount, before
        initialize.  This is so the hacky "fake-upgrade" for custom components
        works for the automated tests. Logically, it should probably be invoked
        in the constructor.
        */</span>
        <span class="hljs-built_in">this</span>.setupCParts();
        <span class="hljs-built_in">this</span>.lifecycle([<span class="hljs-string">'initialized'</span>])
        <span class="hljs-built_in">this</span>.rerender();
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isMounted &amp;&amp; !(<span class="hljs-string">'template'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.cparts)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-59">§</a>
              </div>
              <p>TODO: Make ‘template’ not hardcoded here, as well as
Component’s updateCallback. OR do attrs?</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        }
        <span class="hljs-built_in">this</span>.isMounted = <span class="hljs-literal">true</span>;
    }
}

Modulo.collectDirectives = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectDirectives</span>(<span class="hljs-params">component, el, arr</span>) </span>{
    <span class="hljs-keyword">if</span> (!arr) {
        arr = []; <span class="hljs-comment">// HACK for testability</span>
    }
    <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> for "pre-load" directives, possibly just pass in "Loader" as
       "component" so we can have load-time directives */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> rawName <span class="hljs-keyword">of</span> el.getAttributeNames()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-60">§</a>
              </div>
              <p>todo: optimize skipping most elements or attributes</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">let</span> name = rawName;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [regexp, dir] <span class="hljs-keyword">of</span> Modulo.directiveShortcuts) {
            <span class="hljs-keyword">if</span> (rawName.match(regexp)) {
                name = <span class="hljs-string">`[<span class="hljs-subst">${dir}</span>]`</span> + name.replace(regexp, <span class="hljs-string">''</span>);
            }
        }
        <span class="hljs-keyword">if</span> (!name.startsWith(<span class="hljs-string">'['</span>)) {
            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// There are no directives, skip</span>
        }
        <span class="hljs-keyword">const</span> value = el.getAttribute(rawName);
        <span class="hljs-keyword">const</span> attrName = cleanWord((name.match(<span class="hljs-regexp">/\][^\]]+$/</span>) || [<span class="hljs-string">''</span>])[<span class="hljs-number">0</span>]);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dName <span class="hljs-keyword">of</span> name.split(<span class="hljs-string">']'</span>).map(cleanWord)) {
            <span class="hljs-keyword">if</span> (dName === attrName) {
                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip bare name</span>
            }
            <span class="hljs-keyword">const</span> setUp = component.resolveValue(dName + <span class="hljs-string">'Mount'</span>);
            <span class="hljs-keyword">const</span> tearDown = component.resolveValue(dName + <span class="hljs-string">'Unmount'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-61">§</a>
              </div>
              <p>console.log(‘dName’, dName, attrName, component);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            Modulo.assert(setUp || tearDown, <span class="hljs-string">`Unknown directive: "<span class="hljs-subst">${dName}</span>"`</span>);
            arr.push({el, value, attrName, rawName, setUp, tearDown, dName})
        }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> el.children) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-62">§</a>
              </div>
              <p>tail recursion into children</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        Modulo.collectDirectives(component, child, arr);
    }
    <span class="hljs-keyword">return</span> arr; <span class="hljs-comment">// HACK for testability</span>
}

Modulo.directiveShortcuts = [[<span class="hljs-regexp">/^@/</span>, <span class="hljs-string">'component.event'</span>],
                             [<span class="hljs-regexp">/:$/</span>, <span class="hljs-string">'component.resolve'</span>] ];

Modulo.ComponentPart = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">loadCallback</span>(<span class="hljs-params">node, loader, loadObj</span>)</span> {
        <span class="hljs-keyword">const</span> options = Modulo.utils.parseAttrs(node);
        <span class="hljs-keyword">const</span> content = node.tagName === <span class="hljs-string">'TEMPLATE'</span> ? node.innerHTML
                                                    : node.textContent;
        <span class="hljs-keyword">return</span> {options, content};
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">factoryCallback</span>(<span class="hljs-params"></span>)</span> {}

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element, options</span>)</span> {
        <span class="hljs-built_in">this</span>.component = element; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove</span>
        <span class="hljs-built_in">this</span>.element = element;
        <span class="hljs-built_in">this</span>.options = options.options;
        <span class="hljs-built_in">this</span>.content = options.content;
    }
}

Modulo.cparts.component = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-function"><span class="hljs-title">prepareCallback</span>(<span class="hljs-params"></span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-63">§</a>
              </div>
              <p>TODO shouldn’t have to do this —v</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">eventMount</span>: <span class="hljs-built_in">this</span>.eventMount.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">eventUnmount</span>: <span class="hljs-built_in">this</span>.eventUnmount.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">resolveMount</span>: <span class="hljs-built_in">this</span>.resolveMount.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">resolveUnmount</span>: <span class="hljs-built_in">this</span>.resolveUnmount.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">childrenMount</span>: <span class="hljs-built_in">this</span>.childrenMount.bind(<span class="hljs-built_in">this</span>),
            <span class="hljs-attr">childrenUnmount</span>: <span class="hljs-built_in">this</span>.childrenUnmount.bind(<span class="hljs-built_in">this</span>),
        };
    }

    <span class="hljs-function"><span class="hljs-title">updateCallback</span>(<span class="hljs-params">renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> {component} = <span class="hljs-built_in">this</span>;
        <span class="hljs-keyword">let</span> newContents = (renderObj.template || {}).renderedOutput || <span class="hljs-string">''</span>;
        component.reconcile(component, newContents);
    }

    <span class="hljs-function"><span class="hljs-title">handleEvent</span>(<span class="hljs-params">func, ev, payload</span>)</span> {
        <span class="hljs-built_in">this</span>.element.lifecycle([<span class="hljs-string">'event'</span>], {<span class="hljs-attr">_eventFunction</span>: func});
        func.call(<span class="hljs-literal">null</span>, ev, payload); <span class="hljs-comment">// todo: bind to array.push etc, or get autobinding in resolveValue</span>
        <span class="hljs-built_in">this</span>.element.lifecycle([<span class="hljs-string">'eventCleanup'</span>]); <span class="hljs-comment">// todo: should this go below rerender()?</span></pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-64">§</a>
              </div>
              <p>TODO: Add if (!this.component.options.controlledRender)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-built_in">this</span>.element.rerender(); <span class="hljs-comment">// always rerender after events</span>
    }

    <span class="hljs-function"><span class="hljs-title">childrenMount</span>(<span class="hljs-params">{el}</span>)</span> {
        el.append(...this.element.originalChildren);</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-65">§</a>
              </div>
              <p>this.element.originalChildren = [];</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    }

    <span class="hljs-function"><span class="hljs-title">childrenUnmount</span>(<span class="hljs-params"></span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-66">§</a>
              </div>
              <p>this.element.innerHTML = ‘’;</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    }

    <span class="hljs-function"><span class="hljs-title">eventMount</span>(<span class="hljs-params">info</span>)</span> {
        <span class="hljs-keyword">const</span> {el, value, attrName, rawName} = info;
        <span class="hljs-keyword">const</span> getAttr = getGetAttr(el);</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-67">§</a>
              </div>
              <p>console.log(‘this is eventMount’, info);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> listener = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-68">§</a>
              </div>
              <p>window.C = this;
console.log(‘this is rawName’, rawName, value);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-keyword">const</span> func = getAttr(attrName, getAttr(rawName));
            Modulo.assert(func, <span class="hljs-string">`Bad <span class="hljs-subst">${attrName}</span>, <span class="hljs-subst">${value}</span> is <span class="hljs-subst">${func}</span>`</span>);
            <span class="hljs-keyword">const</span> payload = getAttr(<span class="hljs-string">`<span class="hljs-subst">${attrName}</span>.payload`</span>, el.value);
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this is payload'</span>, <span class="hljs-string">`<span class="hljs-subst">${attrName}</span>.payload`</span>, payload);
            <span class="hljs-built_in">this</span>.handleEvent(func, ev, payload);
        };
        info.listener = listener;
        el.addEventListener(attrName, listener);
    }

    <span class="hljs-function"><span class="hljs-title">eventUnmount</span>(<span class="hljs-params">{attrName, listener}</span>)</span> {
        el.removeEventListener(attrName, listener);
    }

    <span class="hljs-function"><span class="hljs-title">resolveMount</span>(<span class="hljs-params">{el, value, attrName, resolutionContext}</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-69">§</a>
              </div>
              <p>console.log(‘this is it’, resolutionContext);
console.log(‘this is resolve mount’, attrName, value);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> resolvedValue = resolutionContext.resolveValue(value);
        el.attrs = <span class="hljs-built_in">Object</span>.assign(el.attrs || {}, {[attrName]: resolvedValue});
        el.getAttr = <span class="hljs-function">(<span class="hljs-params">n, def</span>) =&gt;</span> {
            <span class="hljs-keyword">let</span> val;
            <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">in</span> el.attrs) {
                val = el.attrs[n];
            } <span class="hljs-keyword">else</span> {
                val = el.getAttribute(n) || def;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-70">§</a>
              </div>
              <p>console.log(‘——————-‘, n, val);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-keyword">return</span> val;
        };
    }
    <span class="hljs-function"><span class="hljs-title">resolveUnmount</span>(<span class="hljs-params">{el, attrName}</span>)</span> {
        <span class="hljs-keyword">delete</span> el.attrs[attrName];
    }
}

Modulo.cparts.props = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Props</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">factoryCallback</span>(<span class="hljs-params">{options}, {componentClass}, renderObj</span>)</span> {
        <span class="hljs-comment">/* untested / daedcode ---v */</span>
        componentClass.observedAttributes = <span class="hljs-built_in">Object</span>.keys(options);
    }

    <span class="hljs-function"><span class="hljs-title">copyMount</span>(<span class="hljs-params">{el}</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-71">§</a>
              </div>
              <p>dead code?
change to “this.element”</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> attr <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.element.getAttributeNames()) {
            el.setAttribute(attr, <span class="hljs-built_in">this</span>.element.getAttribute(attr));
        }
        <span class="hljs-comment">/*
        const props = {};
        for (let propName of Object.keys(this.options)) {
            propName = propName.replace(/:$/, ''); // normalize
            let attrName = this.element.resolveAttributeName(propName);
            if (!attrName) {
                console.error('Prop', propName, 'is required for', this.element.tagName);
                continue;
            }
            let value = this.element.getAttribute(attrName);
            if (attrName.endsWith(':')) {
                attrName = attrName.slice(0, -1); // trim ':'
                value = this.element.moduloRenderContext.resolveValue(value);
            }
            props[propName] = value;
        }
        */</span>
    }

    <span class="hljs-function"><span class="hljs-title">initializedCallback</span>(<span class="hljs-params">renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> props = {};
        <span class="hljs-keyword">const</span> getAttr = getGetAttr(<span class="hljs-built_in">this</span>.element);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propName <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.options)) {
            propName = propName.replace(<span class="hljs-regexp">/:$/</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// TODO, make func to normalize directives</span>
            props[propName] = getAttr(propName);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-72">§</a>
              </div>
              <p>console.log(‘this is props’, props);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">return</span> props;
    }
}

<span class="hljs-comment">/*
Modulo.cparts.attributes = class Attributes extends Modulo.ComponentPart {
    initializedCallback() {
        for (let [name, value] of Object.entries(this.options)) {
            if (name.includes('.')) {
                name = '[' + nae
            }
            this.element.setAttribute(name, value);
        }
    }
}
*/</span>

Modulo.cparts.style = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Style</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">factoryCallback</span>(<span class="hljs-params">{content}, factory, renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> {fullName} = factory;
        <span class="hljs-keyword">const</span> id = <span class="hljs-string">`<span class="hljs-subst">${fullName}</span>_style`</span>;
        <span class="hljs-keyword">let</span> elem = Modulo.globals.document.getElementById(id);
        <span class="hljs-keyword">if</span> (!elem) {
            elem = Modulo.globals.document.createElement(<span class="hljs-string">'style'</span>);
            elem.id = id;
            Modulo.globals.document.head.append(elem)
        }
        elem.textContent = content;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">prefixAllSelectors</span>(<span class="hljs-params">namespace, name, text=<span class="hljs-string">''</span></span>)</span> {
        <span class="hljs-keyword">const</span> fullName = <span class="hljs-string">`<span class="hljs-subst">${namespace}</span>-<span class="hljs-subst">${name}</span>`</span>;
        <span class="hljs-keyword">let</span> content = text.replace(<span class="hljs-regexp">/\*\/.*?\*\//ig</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// strip comments</span></pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-73">§</a>
              </div>
              <p>To prefix the selectors, we loop through them, with this RegExp that
looks for { chars</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        content = content.replace(<span class="hljs-regexp">/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/gi</span>, <span class="hljs-function"><span class="hljs-params">selector</span> =&gt;</span> {
            selector = selector.trim();
            <span class="hljs-keyword">if</span> (selector.startsWith(<span class="hljs-string">'@'</span>) || selector.startsWith(fullName)
                  || selector.startsWith(<span class="hljs-string">'from'</span>) || selector.startsWith(<span class="hljs-string">'to'</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-74">§</a>
              </div>
              <p>TODO: Make a regexp to check if matches other keyframe
stuff, 90% etc
Skip, is @media or @keyframes, or already prefixed</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                <span class="hljs-keyword">return</span> selector;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-75">§</a>
              </div>
              <p>Upgrade the “bare” component name to be the full name</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            selector = selector.replace(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(name, <span class="hljs-string">'ig'</span>), fullName);</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-76">§</a>
              </div>
              <p>If it is not prefixed at this point, then be sure to prefix</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-keyword">if</span> (!selector.startsWith(fullName)) {
                selector = <span class="hljs-string">`<span class="hljs-subst">${fullName}</span> <span class="hljs-subst">${selector}</span>`</span>;
            }
            <span class="hljs-keyword">return</span> selector;
        });
        <span class="hljs-keyword">return</span> content;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">loadCallback</span>(<span class="hljs-params">node, loader, loadObj</span>)</span> {
        <span class="hljs-keyword">let</span> {content, options} = <span class="hljs-built_in">super</span>.loadCallback(node, loader, loadObj);
        <span class="hljs-keyword">const</span> {name} = loadObj.component[<span class="hljs-number">0</span>];
        content = Modulo.cparts.style.prefixAllSelectors(loader.namespace, name, content);
        <span class="hljs-keyword">return</span> {options, content};
    }
}


Modulo.cparts.template = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">factoryCallback</span>(<span class="hljs-params">opts, factory, renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> {loader} = factory;
        <span class="hljs-keyword">const</span> tagPref = <span class="hljs-string">'$1'</span> + loader.namespace + <span class="hljs-string">'-'</span>;
        <span class="hljs-keyword">const</span> content = (opts.content || <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/(&lt;\/?)my-/ig</span>, tagPref);
        <span class="hljs-keyword">const</span> engineName = opts.engine || <span class="hljs-string">'MTL'</span>;
        <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Modulo.templating[engineName](content, opts);
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">compiledTemplate</span>: <span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> instance.render(ctx)};
    }
    <span class="hljs-function"><span class="hljs-title">renderCallback</span>(<span class="hljs-params">renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> compiledTemplate = renderObj.template.compiledTemplate;
        <span class="hljs-keyword">const</span> context = renderObj;
        <span class="hljs-keyword">const</span> result = compiledTemplate(context);
        <span class="hljs-keyword">if</span> (result.includes(<span class="hljs-string">'undefined'</span>)) {
            <span class="hljs-comment">/* console.log('undefined me', renderObj); */</span>
        }
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">renderedOutput</span>: result, compiledTemplate};
    }
}


Modulo.cparts.script = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Script</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getSymbolsAsObjectAssignment</span>(<span class="hljs-params">contents</span>)</span> {
        <span class="hljs-keyword">const</span> regexpG = <span class="hljs-regexp">/function\s+(\w+)/g</span>;
        <span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/function\s+(\w+)/</span>; <span class="hljs-comment">// hack, refactor</span>
        <span class="hljs-keyword">const</span> matches = contents.match(regexpG) || [];
        <span class="hljs-keyword">return</span> matches.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.match(regexp2)[<span class="hljs-number">1</span>])
            .map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-string">`"<span class="hljs-subst">${s}</span>": typeof <span class="hljs-subst">${s}</span> !== "undefined" ? <span class="hljs-subst">${s}</span> : undefined,\n`</span>)
            .join(<span class="hljs-string">''</span>);
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">wrapJavaScriptContext</span>(<span class="hljs-params">contents, localVars</span>)</span> {
        <span class="hljs-keyword">const</span> symbolsString = <span class="hljs-built_in">this</span>.getSymbolsAsObjectAssignment(contents);
        <span class="hljs-keyword">const</span> localVarsLet = localVars.join(<span class="hljs-string">','</span>) || <span class="hljs-string">'noLocalVars=true'</span>;
        <span class="hljs-keyword">const</span> localVarsIfs = localVars
          .map(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-string">`if (name === '<span class="hljs-subst">${n}</span>') <span class="hljs-subst">${n}</span> = value;`</span>).join(<span class="hljs-string">'\n'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-77">§</a>
              </div>
              <p>TODO: Rename script to script to be consistent with event-time lifecycle</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">return</span> <span class="hljs-string">`
            'use strict';
            var <span class="hljs-subst">${localVarsLet}</span>;
            var script = {exports: {}};
            function __set(name, value) { <span class="hljs-subst">${localVarsIfs}</span> }
            <span class="hljs-subst">${contents}</span>
            return { <span class="hljs-subst">${symbolsString}</span> setLocalVariable: __set, exports: script.exports};
        `</span>;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">factoryCallback</span>(<span class="hljs-params">partOptions, factory, renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> code = partOptions.content || <span class="hljs-string">''</span>;
        <span class="hljs-keyword">const</span> localVars = <span class="hljs-built_in">Object</span>.keys(renderObj);
        localVars.push(<span class="hljs-string">'element'</span>); <span class="hljs-comment">// add in element as a local var</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-78">§</a>
              </div>
              <p>localVars.push(‘parent’); // add in access to previous versions of renderObj (DEAD CODE)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        localVars.push(<span class="hljs-string">'cparts'</span>);
        <span class="hljs-keyword">const</span> wrappedJS = <span class="hljs-built_in">this</span>.wrapJavaScriptContext(code, localVars);
        <span class="hljs-keyword">const</span> results = (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'Modulo,factory'</span>, wrappedJS)).call(<span class="hljs-literal">null</span>, Modulo, factory);
        results.localVars = localVars;
        <span class="hljs-keyword">return</span> results;
    }

    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element, options</span>)</span> {
        <span class="hljs-built_in">super</span>(element, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-79">§</a>
              </div>
              <p>Attach callbacks from script to this, to hook into lifecycle.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> {script} = element.initRenderObj;
        <span class="hljs-keyword">const</span> cbs = <span class="hljs-built_in">Object</span>.keys(script)
            .filter(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key.endsWith(<span class="hljs-string">'Callback'</span>) || key.endsWith(<span class="hljs-string">'Mount'</span>));
        cbs.push(<span class="hljs-string">'initializedCallback'</span>, <span class="hljs-string">'eventCallback'</span>); <span class="hljs-comment">// always CBs for these</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cbName <span class="hljs-keyword">of</span> cbs) {
            <span class="hljs-built_in">this</span>[cbName] = <span class="hljs-function"><span class="hljs-params">renderObj</span> =&gt;</span> {
                <span class="hljs-built_in">this</span>.prepLocalVars(renderObj);
                <span class="hljs-keyword">if</span> (cbName <span class="hljs-keyword">in</span> script) {
                    script[cbName](renderObj);
                }
            };
        }
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-80">§</a>
              </div>
              <h2 id="cpartsscript-preplocalvars">cparts.Script: prepLocalVars</h2>

            </div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-81">§</a>
              </div>
              <p>To allow for local variables access to APIs provided by other CParts,
sets local variables equal to the data returned by their callbacks.
This is important: It’s what enables us to avoid using the “this”
context, since the current element is set before any custom code is run.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-function"><span class="hljs-title">prepLocalVars</span>(<span class="hljs-params">renderObj</span>)</span> {
        <span class="hljs-keyword">const</span> {setLocalVariable, localVars} = renderObj.script;
        setLocalVariable(<span class="hljs-string">'element'</span>, <span class="hljs-built_in">this</span>.element);
        setLocalVariable(<span class="hljs-string">'cparts'</span>, <span class="hljs-built_in">this</span>.element.cparts);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> localVar <span class="hljs-keyword">of</span> localVars) {
            <span class="hljs-keyword">if</span> (localVar <span class="hljs-keyword">in</span> renderObj) {
                setLocalVariable(localVar, renderObj[localVar]);
            }
        }
    }
}

Modulo.cparts.state = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Modulo</span>.<span class="hljs-title">ComponentPart</span> </span>{
    <span class="hljs-keyword">static</span> debugGhost = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">get</span> <span class="hljs-title">debugGhost</span>() { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
    <span class="hljs-function"><span class="hljs-title">initializedCallback</span>(<span class="hljs-params">renderObj</span>)</span> {
        <span class="hljs-built_in">this</span>.rawDefaults = renderObj.state.options || {};
        <span class="hljs-built_in">this</span>.boundElements = {};
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.data) {
            <span class="hljs-built_in">this</span>.data = Modulo.utils.simplifyResolvedLiterals(<span class="hljs-built_in">this</span>.rawDefaults);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-82">§</a>
              </div>
              <p>TODO —v delete these</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-built_in">this</span>.data.bindMount = <span class="hljs-built_in">this</span>.bindMount.bind(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// Ugh hack</span>
        <span class="hljs-built_in">this</span>.data.bindUnmount = <span class="hljs-built_in">this</span>.bindUnmount.bind(<span class="hljs-built_in">this</span>);<span class="hljs-comment">// Ugh hack</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data;
    }

    <span class="hljs-function"><span class="hljs-title">bindMount</span>(<span class="hljs-params">{el}</span>)</span> {
        el.getAttr = el.getAttr || el.getAttribute;
        <span class="hljs-keyword">const</span> name = el.getAttr(<span class="hljs-string">'name'</span>);
        Modulo.assert(name <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.data, <span class="hljs-string">`[state.bind]: no "<span class="hljs-subst">${name}</span>" in state`</span>);
        <span class="hljs-keyword">const</span> func = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.set(name, el.value);</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-83">§</a>
              </div>
              <p>eventually customizable, eg [state.bind]mouseover=mouseY (event
name, el property name, and/or state propery name etc)</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> evName = <span class="hljs-string">'keyup'</span>;
        <span class="hljs-built_in">this</span>.boundElements[name] = [el, evName, func];
        el.value = <span class="hljs-built_in">this</span>.data[name];
        el.addEventListener(evName, func);
    }

    <span class="hljs-function"><span class="hljs-title">bindUnmount</span>(<span class="hljs-params">{elem}</span>)</span> {
        <span class="hljs-keyword">const</span> name = elem.getAttr(<span class="hljs-string">'name'</span>);
        <span class="hljs-keyword">const</span> [el, func, evName] = <span class="hljs-built_in">this</span>.boundElements[name];
        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">this</span>.boundElements[name];
        el.removeEventListener(evName, func);
    }

    <span class="hljs-function"><span class="hljs-title">reloadCallback</span>(<span class="hljs-params">oldPart</span>)</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-84">§</a>
              </div>
              <p>Used for hot-reloading: Merge data with oldPart’s data</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-built_in">this</span>.data = <span class="hljs-built_in">Object</span>.assign({}, oldPart.data, <span class="hljs-built_in">this</span>.data, oldPart.data);
    }

    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">name, value</span>)</span> {
        <span class="hljs-built_in">this</span>.data[name] = value;
        <span class="hljs-built_in">this</span>.component.rerender();
    }

    <span class="hljs-function"><span class="hljs-title">eventCallback</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>._oldData = <span class="hljs-built_in">Object</span>.assign({}, <span class="hljs-built_in">this</span>.data);
    }

    <span class="hljs-function"><span class="hljs-title">eventCleanupCallback</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> name <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>.data)) {
            <span class="hljs-keyword">const</span> msg = <span class="hljs-string">`Tried to assign to "state.<span class="hljs-subst">${name}</span>"`</span>;
            Modulo.assert(name <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>._oldData, msg);
            <span class="hljs-keyword">if</span> (name <span class="hljs-keyword">in</span> <span class="hljs-built_in">this</span>.boundElements) {
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.data[name] !== <span class="hljs-built_in">this</span>._oldData[name]) {
                    <span class="hljs-keyword">const</span> [el, func, evName] = <span class="hljs-built_in">this</span>.boundElements[name];
                    el.value = <span class="hljs-built_in">this</span>.data[name];
                }
            }
        }
        <span class="hljs-built_in">this</span>._oldData = <span class="hljs-literal">null</span>;
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-85">§</a>
              </div>
              <p>ModuloTemplate</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.templating.MTL = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModuloTemplateLanguage</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">text, options = {}</span>)</span> {
        <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>, Modulo.templating.defaultOptions, options);
        <span class="hljs-built_in">this</span>.opAliases[<span class="hljs-string">'not in'</span>] = <span class="hljs-string">`!(<span class="hljs-subst">${<span class="hljs-built_in">this</span>.opAliases[<span class="hljs-string">'in'</span>]}</span>)`</span>;
        <span class="hljs-built_in">this</span>.renderFunc = <span class="hljs-built_in">this</span>.compile(text);
    }

    <span class="hljs-function"><span class="hljs-title">tokenizeText</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-keyword">const</span> re = <span class="hljs-string">'('</span> + <span class="hljs-built_in">this</span>.modeTokens.join(<span class="hljs-string">'|('</span>).replace(<span class="hljs-regexp">/ +/g</span>, <span class="hljs-string">')(.+?)'</span>);
        <span class="hljs-keyword">return</span> text.split(<span class="hljs-built_in">RegExp</span>(re)).filter(<span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> token !== <span class="hljs-literal">undefined</span>);
    }

    <span class="hljs-function"><span class="hljs-title">compile</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-built_in">this</span>.stack = []; <span class="hljs-comment">// Template tag stack</span>
        <span class="hljs-keyword">let</span> output = <span class="hljs-string">'var OUT=[];'</span>;
        <span class="hljs-keyword">let</span> mode = <span class="hljs-string">'text'</span>; <span class="hljs-comment">// Start in text mode</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> token <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.tokenizeText(text)) {
            <span class="hljs-keyword">if</span> (mode) {
                <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">this</span>.modes[mode](token, <span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>.stack);
                output += result || <span class="hljs-string">''</span>;
            }
            mode = (mode === <span class="hljs-string">'text'</span>) ? <span class="hljs-literal">null</span> : (mode ? <span class="hljs-string">'text'</span> : token);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-86">§</a>
              </div>
              <p>console.log(‘this is the rsulting template code’, output.replace(/([;}{])/g, ‘$1\n’));</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">'CTX,G'</span>, output + <span class="hljs-string">';return OUT.join("");'</span>);
    }

    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params">renderContext</span>)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.renderFunc(<span class="hljs-built_in">Object</span>.assign({}, renderContext), <span class="hljs-built_in">this</span>);
    }

    <span class="hljs-function"><span class="hljs-title">parseExpr</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-keyword">const</span> filters = text.split(<span class="hljs-string">'|'</span>);
        <span class="hljs-keyword">let</span> results = <span class="hljs-built_in">this</span>.parseVal(filters.shift());
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [fName, arg] <span class="hljs-keyword">of</span> filters.map(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.trim().split(<span class="hljs-string">':'</span>))) {
            <span class="hljs-keyword">const</span> argList = arg ? <span class="hljs-string">','</span> + <span class="hljs-built_in">this</span>.parseVal(arg) : <span class="hljs-string">''</span>;
            results = <span class="hljs-string">`G.filters["<span class="hljs-subst">${fName}</span>"](<span class="hljs-subst">${results}</span><span class="hljs-subst">${argList}</span>)`</span>;
        }
        <span class="hljs-keyword">return</span> results;
    }

    <span class="hljs-function"><span class="hljs-title">parseCondExpr</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-keyword">const</span> reText = <span class="hljs-string">` (<span class="hljs-subst">${<span class="hljs-built_in">this</span>.opTokens.split(<span class="hljs-string">','</span>).join(<span class="hljs-string">'|'</span>)}</span>) `</span>;
        <span class="hljs-keyword">return</span> text.split(<span class="hljs-built_in">RegExp</span>(reText));
    }

    <span class="hljs-function"><span class="hljs-title">parseVal</span>(<span class="hljs-params">s</span>)</span> {
        s = s.trim();
        <span class="hljs-keyword">if</span> (s.match(<span class="hljs-regexp">/^('.*'|".*")$/</span>)) { <span class="hljs-comment">// String literal</span>
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.stringify(s.substr(<span class="hljs-number">1</span>, s.length - <span class="hljs-number">2</span>));
        }
        <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/^\d+$/</span>) ? s : <span class="hljs-string">`CTX.<span class="hljs-subst">${cleanWord(s)}</span>`</span>
    }

    <span class="hljs-function"><span class="hljs-title">escapeHTML</span>(<span class="hljs-params">text</span>)</span> {
        <span class="hljs-keyword">if</span> (text &amp;&amp; text.safe) {
            <span class="hljs-keyword">return</span> text;
        }
        <span class="hljs-keyword">return</span> (text + <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">'&amp;amp;'</span>)
            .replace(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">'&amp;lt;'</span>).replace(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">'&amp;gt;'</span>);
    }
}
Modulo.Template = Modulo.templating.MTL; <span class="hljs-comment">// Alias</span>

Modulo.templating.defaultOptions = {
    <span class="hljs-attr">modeTokens</span>: [<span class="hljs-string">'{% %}'</span>, <span class="hljs-string">'{{ }}'</span>, <span class="hljs-string">'{# #}'</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-87">§</a>
              </div>
              <p>opTokens: ‘==,&gt;,&lt;,&gt;=,&lt;=,!=,not in,is not,is,in,not,and,or’,</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    opTokens: <span class="hljs-string">'==,&gt;,&lt;,&gt;=,&lt;=,!=,not in,is not,is,in,not'</span>,
    <span class="hljs-attr">opAliases</span>: {
        <span class="hljs-string">'=='</span>: <span class="hljs-string">'X === Y'</span>,
        <span class="hljs-string">'is'</span>: <span class="hljs-string">'X === Y'</span>,
        <span class="hljs-string">'is not'</span>: <span class="hljs-string">'X !== Y'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-88">§</a>
              </div>
              <p>‘and’: ‘X &amp;&amp; Y’,
‘or’: ‘X || Y’,</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-string">'not'</span>: <span class="hljs-string">'!(Y)'</span>,
        <span class="hljs-string">'in'</span>: <span class="hljs-string">'typeof Y[X] !== "undefined" || Y.indexOf &amp;&amp; Y.indexOf(X) != -1'</span>,
    },
};

Modulo.templating.defaultOptions.modes = {
    <span class="hljs-string">'{%'</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt, stack</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> tTag = text.trim().split(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">const</span> tagFunc = tmplt.tags[tTag];
        <span class="hljs-keyword">if</span> (stack.length &amp;&amp; tTag === stack[stack.length - <span class="hljs-number">1</span>].close) {
            <span class="hljs-keyword">return</span> stack.pop().end; <span class="hljs-comment">// Closing tag, return it's end code</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tagFunc) { <span class="hljs-comment">// Undefined template tag</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown template tag "<span class="hljs-subst">${tTag}</span>": <span class="hljs-subst">${text}</span>`</span>);
        } <span class="hljs-comment">// Normal opening tag</span>
        <span class="hljs-keyword">const</span> result = tagFunc(text.slice(tTag.length + <span class="hljs-number">1</span>), tmplt);
        <span class="hljs-keyword">if</span> (result.end) { <span class="hljs-comment">// Not self-closing, push to stack</span>
            stack.push({<span class="hljs-attr">close</span>: <span class="hljs-string">`end<span class="hljs-subst">${tTag}</span>`</span>, ...result});
        }
        <span class="hljs-keyword">return</span> result.start || result;
    },
    <span class="hljs-string">'{#'</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt</span>) =&gt;</span> {},
    <span class="hljs-string">'{{'</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt</span>) =&gt;</span> <span class="hljs-string">`OUT.push(G.escapeHTML(<span class="hljs-subst">${tmplt.parseExpr(text)}</span>));`</span>,
    <span class="hljs-attr">text</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt</span>) =&gt;</span> text &amp;&amp; <span class="hljs-string">`OUT.push(<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(text)}</span>);`</span>,
};

Modulo.templating.defaultOptions.filters = {
    <span class="hljs-attr">upper</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.toUpperCase(),
    <span class="hljs-attr">lower</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.toLowerCase(),
    <span class="hljs-attr">escapejs</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(s),
    <span class="hljs-attr">first</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s[<span class="hljs-number">0</span>],
    <span class="hljs-attr">last</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s[s.length - <span class="hljs-number">1</span>],
    <span class="hljs-attr">length</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.length,
    <span class="hljs-attr">safe</span>: <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(s), {<span class="hljs-attr">safe</span>: <span class="hljs-literal">true</span>}),
    <span class="hljs-attr">join</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> s.join(arg),
    <span class="hljs-attr">pluralize</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> arg.split(<span class="hljs-string">','</span>)[(s === <span class="hljs-number">1</span>) * <span class="hljs-number">1</span>],
    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> s + arg,
    <span class="hljs-attr">subtract</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> s - arg,
    <span class="hljs-attr">default</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> s || arg,</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-89">§</a>
              </div>
              <p>invoke: (s, arg) =&gt; s(arg),
getAttribute: (s, arg) =&gt; s.getAttribute(arg),</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    includes: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> s.includes(arg),
    <span class="hljs-attr">divisibleby</span>: <span class="hljs-function">(<span class="hljs-params">s, arg</span>) =&gt;</span> ((s * <span class="hljs-number">1</span>) % (arg * <span class="hljs-number">1</span>)) === <span class="hljs-number">0</span>,
};

Modulo.templating.defaultOptions.tags = {
    <span class="hljs-string">'if'</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> [lHand, op, rHand] = tmplt.parseCondExpr(text);
        <span class="hljs-keyword">const</span> condStructure = !op ? <span class="hljs-string">'X'</span> : tmplt.opAliases[op] || <span class="hljs-string">`X <span class="hljs-subst">${op}</span> Y`</span>;
        <span class="hljs-keyword">const</span> condition = condStructure.replace(<span class="hljs-regexp">/([XY])/g</span>,
            <span class="hljs-function">(<span class="hljs-params">k, m</span>) =&gt;</span> tmplt.parseExpr(m === <span class="hljs-string">'X'</span> ? lHand : rHand));
        <span class="hljs-keyword">const</span> start = <span class="hljs-string">`if (<span class="hljs-subst">${condition}</span>) {`</span>;
        <span class="hljs-keyword">return</span> {start, <span class="hljs-attr">end</span>: <span class="hljs-string">'}'</span>};
    },
    <span class="hljs-string">'else'</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">'} else {'</span>,
    <span class="hljs-string">'elif'</span>: <span class="hljs-function">(<span class="hljs-params">s, tmplt</span>) =&gt;</span> <span class="hljs-string">'} else '</span> + tmplt.tags[<span class="hljs-string">'if'</span>](s, tmplt).start,
    <span class="hljs-string">'comment'</span>: <span class="hljs-function">() =&gt;</span> ({ <span class="hljs-attr">start</span>: <span class="hljs-string">"/*"</span>, <span class="hljs-attr">end</span>: <span class="hljs-string">"*/"</span>}),
    <span class="hljs-string">'for'</span>: <span class="hljs-function">(<span class="hljs-params">text, tmplt</span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-90">§</a>
              </div>
              <p>Make variable name be based on nested-ness of tag stack</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> arrName = <span class="hljs-string">'ARR'</span> + tmplt.stack.length;
        <span class="hljs-keyword">const</span> [varExp, arrExp] = text.split(<span class="hljs-string">' in '</span>);
        <span class="hljs-keyword">let</span> start = <span class="hljs-string">`var <span class="hljs-subst">${arrName}</span>=<span class="hljs-subst">${tmplt.parseExpr(arrExp)}</span>;`</span>;
        start += <span class="hljs-string">`for (var KEY in <span class="hljs-subst">${arrName}</span>) {`</span>;
        <span class="hljs-keyword">const</span> [keyVar, valVar] = varExp.split(<span class="hljs-string">','</span>).map(cleanWord);
        <span class="hljs-keyword">if</span> (valVar) {
            start += <span class="hljs-string">`CTX.<span class="hljs-subst">${keyVar}</span>=KEY;`</span>;
        }
        start += <span class="hljs-string">`CTX.<span class="hljs-subst">${valVar ? valVar : varExp}</span>=<span class="hljs-subst">${arrName}</span>[KEY];`</span>;
        <span class="hljs-keyword">return</span> {start, <span class="hljs-attr">end</span>: <span class="hljs-string">'}'</span>};
    },
    <span class="hljs-string">'empty'</span>: <span class="hljs-function">(<span class="hljs-params">text, {stack}</span>) =&gt;</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-91">§</a>
              </div>
              <p>Make variable name be based on nested-ness of tag stack</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        <span class="hljs-keyword">const</span> varName = <span class="hljs-string">'G.FORLOOP_NOT_EMPTY'</span> + stack.length;
        <span class="hljs-keyword">const</span> oldEndCode = stack.pop().end; <span class="hljs-comment">// get rid of dangling for</span>
        <span class="hljs-keyword">const</span> start = <span class="hljs-string">`<span class="hljs-subst">${varName}</span>=true; <span class="hljs-subst">${oldEndCode}</span> if (!<span class="hljs-subst">${varName}</span>) {`</span>;
        <span class="hljs-keyword">const</span> end = <span class="hljs-string">`}<span class="hljs-subst">${varName}</span> = false;`</span>;
        <span class="hljs-keyword">return</span> {start, end, <span class="hljs-attr">close</span>: <span class="hljs-string">'endfor'</span>};
    },
};</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-92">§</a>
              </div>
              <p>SetDomReconciler ——————</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.reconcilers.InnerHtml = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerHtmlReconciler</span> </span>{
    <span class="hljs-function"><span class="hljs-title">reconcile</span>(<span class="hljs-params">element, newHTML</span>)</span> {
        element.innerHTML = newHTML;</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-93">§</a>
              </div>
              <p>TODO, add in directives stuff, move elsewhere</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    }
}
Modulo.reconcilers.SetDom = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetDomReconciler</span> </span>{
    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
        <span class="hljs-built_in">this</span>.KEY = <span class="hljs-string">'key'</span>
        <span class="hljs-built_in">this</span>.IGNORE = <span class="hljs-string">'modulo-ignore'</span>
        <span class="hljs-built_in">this</span>.CHECKSUM = <span class="hljs-string">'modulo-checksum'</span>
        <span class="hljs-built_in">this</span>.KEY_PREFIX = <span class="hljs-string">'_set-dom-'</span>
        <span class="hljs-built_in">this</span>.mockBody = Modulo.globals.document.implementation
                        .createHTMLDocument(<span class="hljs-string">''</span>).body;
    }

    <span class="hljs-function"><span class="hljs-title">reconcile</span>(<span class="hljs-params">element, newHTML</span>)</span> {
        <span class="hljs-built_in">this</span>.elemCtx = element;
        <span class="hljs-keyword">if</span> (!element.isMounted) {
            element.innerHTML = newHTML;
            <span class="hljs-built_in">this</span>.findAndApplyDirectives(element);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">this</span>.mockBody.innerHTML = <span class="hljs-string">`&lt;div&gt;<span class="hljs-subst">${newHTML}</span>&lt;/div&gt;`</span>;
            <span class="hljs-built_in">this</span>.setChildNodes(element, <span class="hljs-built_in">this</span>.mockBody.firstChild);
        }
        <span class="hljs-built_in">this</span>.elemCtx = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-function"><span class="hljs-title">findAndApplyDirectives</span>(<span class="hljs-params">element</span>)</span> {
        <span class="hljs-keyword">const</span> directives = [];
        <span class="hljs-keyword">if</span> (!element.children) {</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-94">§</a>
              </div>
              <p>console.log(‘this is element’, element); // NOT sure why text nodes get here</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> element.children) {
            Modulo.collectDirectives(<span class="hljs-built_in">this</span>.elemCtx, child, directives);
        }
        <span class="hljs-built_in">this</span>.elemCtx.applyDirectives(directives);
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Updates a specific htmlNode and does whatever it takes to convert it to
      another one.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">oldNode</span></span> - The previous HTMLNode.
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">newNode</span></span> - The updated HTMLNode.
    */</span>
    <span class="hljs-function"><span class="hljs-title">setNode</span>(<span class="hljs-params">oldNode, newNode</span>)</span> {
        <span class="hljs-keyword">if</span> (oldNode.nodeType !== newNode.nodeType ||
                oldNode.nodeName !== newNode.nodeName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-95">§</a>
              </div>
              <p>We have to fully replace the node — the tag/type doesn’t match
this.dismount(oldNode);</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            oldNode.parentNode.replaceChild(newNode, oldNode)
            <span class="hljs-built_in">this</span>.mount(newNode);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldNode.nodeType !== <span class="hljs-number">1</span>) { <span class="hljs-comment">// 1 === ELEMENT_TYPE</span></pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-96">§</a>
              </div>
              <p>Handle other types of node updates (text/comments/etc).
TODO: Is this if statement even a useful optimization..?
if (oldNode.nodeValue !== newNode.nodeValue) {
}</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            oldNode.nodeValue = newNode.nodeValue;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEqualNode(oldNode, newNode)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-97">§</a>
              </div>
              <p>Update children &amp; attributes</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>            <span class="hljs-built_in">this</span>.setChildNodes(oldNode, newNode);
            <span class="hljs-built_in">this</span>.setAttributes(oldNode.attributes, newNode.attributes);</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-98">§</a>
              </div>
              <p>TODO: do dismounts as necessary</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        }
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Utility that will update one list of attributes to match another.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{NamedNodeMap}</span> <span class="hljs-variable">oldAttributes</span></span> - The previous attributes.
    * <span class="hljs-doctag">@param <span class="hljs-type">{NamedNodeMap}</span> <span class="hljs-variable">newAttributes</span></span> - The updated attributes.
    */</span>
    setAttributes (oldAttributes, newAttributes) {
      <span class="hljs-keyword">let</span> i, a, b, ns, name</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-99">§</a>
              </div>
              <p>Remove old attributes.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      <span class="hljs-keyword">for</span> (i = oldAttributes.length; i--;) {
        a = oldAttributes[i]
        ns = a.namespaceURI
        name = a.localName
        b = newAttributes.getNamedItemNS(ns, name)
        <span class="hljs-keyword">if</span> (!b) oldAttributes.removeNamedItemNS(ns, name)
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-100">§</a>
              </div>
              <p>Set new attributes.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      <span class="hljs-keyword">for</span> (i = newAttributes.length; i--;) {
        a = newAttributes[i]
        ns = a.namespaceURI
        name = a.localName
        b = oldAttributes.getNamedItemNS(ns, name)
        <span class="hljs-keyword">if</span> (!b) {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-101">§</a>
              </div>
              <p>Add a new attribute.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>          newAttributes.removeNamedItemNS(ns, name)
          oldAttributes.setNamedItemNS(a)
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b.value !== a.value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-102">§</a>
              </div>
              <p>Update existing attribute.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>          b.value = a.value
        }
      }
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Utility that will nodes childern to match another nodes children.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">oldParent</span></span> - The existing parent node.
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">newParent</span></span> - The new parent node.
    */</span>
    setChildNodes (oldParent, newParent) {
      <span class="hljs-keyword">const</span> keyedNodes = {};
      <span class="hljs-keyword">let</span> checkOld, oldKey, checkNew, newKey, foundNode
      <span class="hljs-keyword">let</span> oldNode = oldParent.firstChild
      <span class="hljs-keyword">let</span> newNode = newParent.firstChild
      <span class="hljs-keyword">let</span> extra = <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-103">§</a>
              </div>
              <p>Extract keyed nodes from previous children and keep track of total
count.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      <span class="hljs-keyword">while</span> (oldNode) {
          extra++
          checkOld = oldNode
          oldKey = <span class="hljs-built_in">this</span>.getKey(checkOld)
          oldNode = oldNode.nextSibling
          <span class="hljs-keyword">if</span> (oldKey) {
              keyedNodes[oldKey] = checkOld
          }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-104">§</a>
              </div>
              <p>Loop over new nodes and perform updates.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      oldNode = oldParent.firstChild
      <span class="hljs-keyword">while</span> (newNode) {
          extra--
          checkNew = newNode
          newNode = newNode.nextSibling

          <span class="hljs-keyword">const</span> newKey = <span class="hljs-built_in">this</span>.getKey(checkNew);
          <span class="hljs-keyword">const</span> foundNode = newKey ? keyedNodes[newKey] : <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">if</span> (foundNode) {
              <span class="hljs-keyword">delete</span> keyedNodes[newKey]</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-105">§</a>
              </div>
              <p>If we have a key and it existed before we move the previous
node to the new position if needed and diff it.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>              <span class="hljs-keyword">if</span> (foundNode !== oldNode) {
                  oldParent.insertBefore(foundNode, oldNode)
              } <span class="hljs-keyword">else</span> {
                  oldNode = oldNode.nextSibling
              }

              <span class="hljs-built_in">this</span>.setNode(foundNode, checkNew)
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldNode) {
              checkOld = oldNode
              oldNode = oldNode.nextSibling
              <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getKey(checkOld)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-106">§</a>
              </div>
              <p>If the old child had a key we skip over it until the end.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                  oldParent.insertBefore(checkNew, checkOld)
                  <span class="hljs-built_in">this</span>.mount(checkNew)
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-107">§</a>
              </div>
              <p>Otherwise we diff the two non-keyed nodes.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>                  <span class="hljs-built_in">this</span>.setNode(checkOld, checkNew)
              }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-108">§</a>
              </div>
              <p>Finally if there was no old node we add the new node.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>              oldParent.appendChild(checkNew)
              <span class="hljs-keyword">if</span> (checkNew.nodeType === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 1 === ELEMENT_TYPE</span>
                  <span class="hljs-built_in">this</span>.mount(checkNew)
              }
          }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-109">§</a>
              </div>
              <p>Remove old keyed nodes.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      <span class="hljs-keyword">for</span> (oldKey <span class="hljs-keyword">in</span> keyedNodes) {
        extra--
        oldParent.removeChild(<span class="hljs-built_in">this</span>.dismount(keyedNodes[oldKey]))
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-110">§</a>
              </div>
              <p>If we have any remaining unkeyed nodes remove them from the end.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>      <span class="hljs-keyword">while</span> (--extra &gt;= <span class="hljs-number">0</span>) {
        oldParent.removeChild(<span class="hljs-built_in">this</span>.dismount(oldParent.lastChild))
      }
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Utility to try to pull a key out of an element.
    * Uses 'data-key' if possible and falls back to 'id'.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">node</span></span> - The node to get the key for.
    * <span class="hljs-doctag">@return <span class="hljs-type">{string|void}</span></span>
    */</span>
    getKey (node) {
      <span class="hljs-keyword">if</span> (node.nodeType !== <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 1 === ELEMENT_TYPE</span>
      <span class="hljs-keyword">let</span> key = node.getAttribute(<span class="hljs-built_in">this</span>.KEY) || node.id
      <span class="hljs-keyword">if</span> (key) <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.KEY_PREFIX + key
    }

    <span class="hljs-comment">/**
    * Checks if nodes are equal using the following by checking if
    * they are both ignored, have the same checksum, or have the
    * same contents.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">a</span></span> - One of the nodes to compare.
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">b</span></span> - Another node to compare.
    */</span>
    isEqualNode (a, b) {
      <span class="hljs-keyword">return</span> (</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-111">§</a>
              </div>
              <p>Check if both nodes are ignored.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        (<span class="hljs-built_in">this</span>.isIgnored(a) &amp;&amp; <span class="hljs-built_in">this</span>.isIgnored(b)) ||</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-112">§</a>
              </div>
              <p>Check if both nodes have the same checksum.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        (<span class="hljs-built_in">this</span>.getCheckSum(a) === <span class="hljs-built_in">this</span>.getCheckSum(b)) ||</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-113">§</a>
              </div>
              <p>Fall back to native isEqualNode check.</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>        a.isEqualNode(b)
      )
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Utility to try to pull a checksum attribute from an element.
    * Uses 'data-checksum' or user specified checksum property.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">node</span></span> - The node to get the checksum for.
    * <span class="hljs-doctag">@return <span class="hljs-type">{string|NaN}</span></span>
    */</span>
    getCheckSum (node) {
      <span class="hljs-keyword">return</span> node.getAttribute(<span class="hljs-built_in">this</span>.CHECKSUM) || <span class="hljs-literal">NaN</span>
    }

    <span class="hljs-comment">/**
    * <span class="hljs-doctag">@private</span>
    * <span class="hljs-doctag">@description</span>
    * Utility to try to check if an element should be ignored by the algorithm.
    * Uses 'data-ignore' or user specified ignore property.
    *
    * <span class="hljs-doctag">@param <span class="hljs-type">{Node}</span> <span class="hljs-variable">node</span></span> - The node to check if it should be ignored.
    * <span class="hljs-doctag">@return <span class="hljs-type">{boolean}</span></span>
    */</span>
    isIgnored (node) {
      <span class="hljs-keyword">return</span> node.getAttribute(<span class="hljs-built_in">this</span>.IGNORE) != <span class="hljs-literal">null</span>
    }

    mount (node) {
        <span class="hljs-built_in">this</span>.findAndApplyDirectives(node);
        <span class="hljs-keyword">return</span> node;
    }
    <span class="hljs-function"><span class="hljs-title">dismount</span>(<span class="hljs-params">node</span>)</span> {
        <span class="hljs-keyword">return</span> node;
    }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-114">§</a>
              </div>
              <p>/setDOM ——————</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>Modulo.utils = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">utils</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">simplifyResolvedLiterals</span>(<span class="hljs-params">attrs</span>)</span> {
        <span class="hljs-keyword">const</span> obj = {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [name, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(attrs)) {
            name = name.replace(<span class="hljs-regexp">/-([a-z])/g</span>, <span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> g[<span class="hljs-number">1</span>].toUpperCase());
            <span class="hljs-keyword">if</span> (name.endsWith(<span class="hljs-string">':'</span>)) {
                name = name.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// slice out colon</span>
                Modulo.assert(value.trim(), <span class="hljs-string">`Invalid literal: <span class="hljs-subst">${name}</span>="<span class="hljs-subst">${value}</span>"`</span>);
                value = <span class="hljs-built_in">JSON</span>.parse(value.trim());
            }
            obj[name] = value;
        }
        <span class="hljs-keyword">return</span> obj;
    }
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">parseAttrs</span>(<span class="hljs-params">elem</span>)</span> {
        <span class="hljs-keyword">const</span> obj = {};
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> name <span class="hljs-keyword">of</span> elem.getAttributeNames()) {
            <span class="hljs-keyword">const</span> value = elem.getAttribute(name);
            name = name.replace(<span class="hljs-regexp">/-([a-z])/g</span>, <span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> g[<span class="hljs-number">1</span>].toUpperCase());
            obj[name] = value;
        }
        <span class="hljs-keyword">return</span> obj;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">obj, key</span>)</span> {
        <span class="hljs-keyword">return</span> key.split(<span class="hljs-string">'.'</span>).reduce(<span class="hljs-function">(<span class="hljs-params">o, name</span>) =&gt;</span> o[name], obj);
    }
}

Modulo.assert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assert</span>(<span class="hljs-params">value, ...info</span>) </span>{
    <span class="hljs-keyword">if</span> (!value) {
        <span class="hljs-built_in">console</span>.error(...info);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Modulo Error: "<span class="hljs-subst">${<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(info).join(<span class="hljs-string">' '</span>)}</span>"`</span>)
    }
}
<span class="hljs-comment">/*
# HACKY FUNCTIONS
Pls ignore all
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGetAttr</span>(<span class="hljs-params">element</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-115">§</a>
              </div>
              <p>HACK</p>

            </div>
            
            <div class="content"><div class="highlight"><pre>    <span class="hljs-keyword">if</span> (element.getAttr) {
        <span class="hljs-keyword">return</span> element.getAttr;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> element.getAttribute(...args);
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanWord</span>(<span class="hljs-params">text</span>) </span>{
    <span class="hljs-keyword">return</span> (text + <span class="hljs-string">''</span>).replace(<span class="hljs-regexp">/[^a-zA-Z0-9$_\.]/g</span>, <span class="hljs-string">''</span>) || <span class="hljs-string">''</span>;
}

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> !== <span class="hljs-string">'undefined'</span>) { <span class="hljs-comment">// Node</span>
    <span class="hljs-built_in">module</span>.exports = Modulo;
}
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> customElements !== <span class="hljs-string">'undefined'</span>) { <span class="hljs-comment">// Browser</span>
    Modulo.globals = <span class="hljs-built_in">window</span>;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>


</body>